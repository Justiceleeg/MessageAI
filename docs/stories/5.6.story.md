# Story 5.6: Proactive Assistant with LangChain

**Epic:** 5 - AI-Powered Messaging Features  
**Story Points:** 6  
**Priority:** High  
**Assigned To:** @dev  
**Status:** Not Started

---

## User Story

**As a** person coordinating multiple plans,  
**I want** AI to warn me about scheduling conflicts before I create an event,  
**so that** I don't accidentally double-book myself.

---

## Description

This is the most sophisticated AI feature, showcasing LangChain's agent capabilities. When a user suggests a meeting time that conflicts with their existing calendar, a LangChain agent:
1. Detects the scheduling intent
2. Uses tools to check the user's calendar
3. Uses tools to search conversation history for context
4. Generates alternative time suggestions
5. Provides a helpful, context-aware response

The agent appears proactive - catching problems before they happen.

---

## Acceptance Criteria

### AC1: Conflict Detection Trigger
- [ ] AI detects scheduling intent: "let's meet", "dinner on", "call at"
- [ ] Extracts proposed date/time
- [ ] Checks if conflicts with existing calendar events
- [ ] If conflict: Shows "⚠️ Add to calendar?" (warning icon)
- [ ] If no conflict: Shows regular "➕ Add to calendar?"

### AC2: LangChain Agent Setup
- [ ] Backend: `POST /api/v1/proactive-assist`
- [ ] Accept: messageText, userCalendar[], conversationContext
- [ ] LangChain agent with GPT-4o-mini
- [ ] Agent has access to 3 tools:
  1. check_calendar: Find conflicts in provided calendar
  2. search_related_messages: Vector search for context
  3. suggest_alternatives: Generate alternative times
- [ ] Agent makes multi-step reasoning
- [ ] Returns structured response

### AC3: Agent Tool: check_calendar
- [ ] Input: Proposed event details
- [ ] Logic: Compare proposed time with userCalendar events
- [ ] Detect overlaps (start/end time comparison)
- [ ] Output: List of conflicting events or "No conflicts"

### AC4: Agent Tool: search_related_messages
- [ ] Input: Search query string
- [ ] Uses Pinecone vector search
- [ ] Searches messages in current conversation
- [ ] Returns top 3 relevant messages for context
- [ ] Output: Formatted message text

### AC5: Agent Tool: suggest_alternatives
- [ ] Input: Conflict details
- [ ] Logic: Suggest times before/after conflict
- [ ] Consider conversation urgency (from context)
- [ ] Output: List of 2-3 alternative times

### AC6: Conflict Warning Modal
- [ ] User taps "⚠️ Add to calendar?"
- [ ] Modal shows:
  - "⚠️ Scheduling Conflict" header
  - "This conflicts with: [Event Name] at [Time]"
  - Agent's reasoning (brief)
  - Suggested alternatives:
    - ○ Change to 2:00 PM
    - ○ Change to 4:30 PM
    - ○ Create anyway
  - [Cancel] [Confirm Choice] buttons

### AC7: Alternative Selection
- [ ] User selects an alternative time
- [ ] Modal updates with new time
- [ ] "Create Event" proceeds with selected time
- [ ] User selects "Create anyway"
- [ ] Creates event despite conflict (user override)

### AC8: Agent Response Quality
- [ ] Agent provides concise reasoning
- [ ] Reasoning mentions specific conflict
- [ ] Suggestions are practical (within same day or adjacent)
- [ ] Agent uses conversation context when available
- [ ] Response generated in < 5 seconds

### AC9: Edge Cases
- [ ] No calendar events: Agent confirms "No conflicts"
- [ ] Multiple conflicts: Shows all, prioritizes by proximity
- [ ] Vague time ("afternoon"): Agent requests clarification or suggests broad window
- [ ] Weekend vs weekday: Agent suggests appropriate alternatives
- [ ] Offline: Conflict detection disabled, standard event creation

---

## Tasks

### Task 1: Backend - Agent Setup (AC2)
- [ ] Create `app/services/agent_service.py`
- [ ] Import LangChain components:
  - ChatOpenAI
  - create_openai_functions_agent
  - AgentExecutor
  - Tool
- [ ] Define system prompt for scheduling assistant
- [ ] Initialize agent with tools
- [ ] Set max_iterations=3 to avoid long runs

### Task 2: Backend - Tool: check_calendar (AC3)
- [ ] Implement `check_calendar` function
- [ ] Parse proposed event time
- [ ] Iterate through userCalendar
- [ ] Detect overlaps with simple time comparison
- [ ] Return formatted conflict list

### Task 3: Backend - Tool: search_related_messages (AC4)
- [ ] Implement `search_related_messages` function
- [ ] Use existing VectorStoreService
- [ ] Search Pinecone namespace "messages"
- [ ] Filter by conversationId
- [ ] Return top 3 results as formatted string

### Task 4: Backend - Tool: suggest_alternatives (AC5)
- [ ] Implement `suggest_alternatives` function
- [ ] Logic: If conflict at 3pm, suggest 2pm and 4pm
- [ ] Consider time of day (don't suggest 11pm)
- [ ] Return list of alternative time strings

### Task 5: Backend - Agent Endpoint (AC2, AC8)
- [ ] Create `app/routes/agent.py`
- [ ] `POST /proactive-assist` endpoint
- [ ] Accept AgentRequest model
- [ ] Call agent_service.analyze()
- [ ] Parse agent output to structured response
- [ ] Return AgentResponse model
- [ ] Handle agent errors gracefully

### Task 6: iOS - Conflict Warning Integration (AC1)
- [ ] When event detected, check for conflicts
- [ ] If user's calendar passed to backend includes overlap:
  - AI response includes conflict=true
  - Show "⚠️" icon instead of "➕"

### Task 7: iOS - Conflict Warning Modal (AC6, AC7)
- [ ] Create `ConflictWarningModal` SwiftUI view
- [ ] Display conflict details
- [ ] Show agent's reasoning
- [ ] Radio buttons for alternatives
- [ ] "Create anyway" option
- [ ] Confirm button applies selected option

### Task 8: iOS - Alternative Time Handling (AC7)
- [ ] When user selects alternative
- [ ] Update event creation with new time
- [ ] Call EventService with modified data
- [ ] Proceed as normal event creation

### Task 9: iOS - User Calendar Passing (AC1)
- [ ] When analyzing message, fetch user's upcoming events
- [ ] Convert to simple format: [{id, title, date, time}]
- [ ] Pass to backend in /analyze-message request
- [ ] Limit to next 7 days to keep payload small

### Task 10: Manual Testing (AC1-9)
- [ ] Setup: Create calendar event "Coffee at 3pm Friday"
- [ ] Test: Send "Let's meet Friday at 3pm"
  - Verify "⚠️" icon appears
  - Open modal
  - Verify shows conflict with Coffee
  - Verify suggestions (2pm, 4pm)
  - Select alternative
  - Verify event created with new time
- [ ] Test: Send "Dinner tomorrow at 7"
  - No conflicts
  - Verify "➕" icon (no warning)
- [ ] Test: Multiple conflicts
  - Verify all listed
- [ ] Test: Offline
  - Verify no conflict detection (expected)

---

## Technical Notes

### LangChain Agent Setup
```python
from langchain_openai import ChatOpenAI
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import Tool
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.2)

tools = [
    Tool(
        name="check_calendar",
        func=self._check_calendar,
        description="Check user's calendar for conflicts with proposed event"
    ),
    Tool(
        name="search_related_messages",
        func=self._search_related_messages,
        description="Search conversation history for relevant context"
    ),
    Tool(
        name="suggest_alternatives",
        func=self._suggest_alternatives,
        description="Suggest alternative meeting times around conflicts"
    )
]

prompt = ChatPromptTemplate.from_messages([
    ("system", """You are a proactive scheduling assistant.
    When user proposes a meeting time:
    1. Check calendar for conflicts
    2. Search conversation for context (urgency, importance)
    3. Suggest alternatives if conflicts exist
    Be concise and helpful."""),
    ("user", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad"),
])

agent = create_openai_functions_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools, max_iterations=3)
```

### Agent Response Structure
```python
# Agent output (natural language)
"I found a conflict with your Coffee meeting at 3pm Friday. \
Based on the conversation, this seems urgent. \
I suggest meeting at 2pm or 4:30pm instead."

# Parsed to structured response
{
    "conflict_detected": true,
    "conflicts": ["Coffee meeting at 15:00"],
    "suggestions": ["14:00", "16:30"],
    "reasoning": "Conflicts with Coffee meeting. Urgent context detected."
}
```

### Conflict Detection Logic
```python
def _check_calendar(self, proposed_event: str) -> str:
    # Parse proposed time from natural language
    proposed_time = parse_time(proposed_event)  # e.g., "Friday 3pm"
    
    conflicts = []
    for event in self.calendar:
        if times_overlap(proposed_time, event):
            conflicts.append(f"{event['title']} at {event['time']}")
    
    if conflicts:
        return f"Conflicts found: {', '.join(conflicts)}"
    return "No conflicts found"
```

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] LangChain agent functional
- [ ] All 3 tools working
- [ ] Conflict warnings appearing
- [ ] Alternative suggestions helpful
- [ ] Agent responses < 5 seconds
- [ ] Manual testing passed
- [ ] Agent reasoning makes sense

---

## Dependencies

**Upstream:**
- Story 5.0 (Backend Foundation)
- Story 5.1 (Smart Calendar Extraction - uses event model)
- Story 5.4 (RSVP Tracking - for complete calendar data)

**Downstream:** None

---

## Testing Strategy

### Manual Test Cases (Primary Validation)

1. **Basic Conflict**
   - Existing: Coffee at 3pm
   - Propose: Meeting at 3pm
   - Expected: Warning, shows conflict, suggests 2pm/4pm

2. **No Conflict**
   - Propose: Meeting at 1pm
   - Expected: No warning, regular event creation

3. **Multiple Conflicts**
   - Existing: Coffee 3pm, Dinner 5pm
   - Propose: Meeting 3pm-6pm
   - Expected: Shows both conflicts

4. **Context-Aware**
   - Previous messages mention urgency
   - Conflict detected
   - Expected: Agent reasoning mentions urgency

5. **Alternative Selection**
   - Select "Change to 2pm"
   - Expected: Event created at 2pm

6. **User Override**
   - Select "Create anyway"
   - Expected: Event created despite conflict

### Unit Testing (Optional)
Unit tests for LangChain agent tools and conflict detection logic may be created but are not required.

**Note:** This story will rely on manual testing for end-to-end validation. Unit tests are optional and may be skipped to meet timeline constraints.

---

## Notes

- This is the "showcase" AI feature - demonstrates agent reasoning
- LangChain agent can seem "intelligent" due to tool usage
- Keep agent iterations low (max 3) to avoid slow responses
- Agent should be helpful, not annoying - only warn on real conflicts

---

## References

- Technical Spec: Section "Proactive Assistant (LangChain Agent)"
- LangChain Agents: https://python.langchain.com/docs/modules/agents/

---

**Story 5.6 demonstrates the power of LangChain agents - AI that can reason, use tools, and provide proactive assistance.**

