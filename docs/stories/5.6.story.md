# Story 5.6: Proactive Assistant with LangChain

**Epic:** 5 - AI-Powered Messaging Features  
**Story Points:** 7  
**Priority:** High  
**Assigned To:** @dev  
**Status:** Not Started

> ⚠️ **BREAKING CHANGE:** This story updates the Event schema to include duration. Requires full database wipe before starting.

---

## User Story

**As a** person coordinating multiple plans,  
**I want** AI to warn me about scheduling conflicts before I create an event,  
**so that** I don't accidentally double-book myself.

---

## Description

This is the most sophisticated AI feature, showcasing LangChain's agent capabilities. When a user suggests a meeting time that conflicts with their existing calendar, a LangChain agent:
1. Detects the scheduling intent
2. Uses tools to check the user's calendar for **overlapping time ranges**
3. Uses tools to search conversation history for context
4. Generates alternative time suggestions
5. Provides a helpful, context-aware response

The agent appears proactive - catching problems before they happen.

**Schema Enhancement:** This story extends the Event model to include `startTime`, `endTime`, and `duration` for proper collision detection. Events can now span time ranges (e.g., "3pm - 5pm") rather than just points in time.

---

## Acceptance Criteria

### AC1: Conflict Detection Trigger
- [ ] AI detects scheduling intent: "let's meet", "dinner on", "call at"
- [ ] Extracts proposed date/time (start and end)
- [ ] **Default Duration:** If end time not specified, assume 1 hour duration
- [ ] Checks if conflicts with existing calendar events (interval overlap)
- [ ] If conflict: Shows "⚠️ Add to calendar?" (warning icon)
- [ ] If no conflict: Shows regular "➕ Add to calendar?"

### AC2: LangChain Agent Setup
- [ ] Backend: `POST /api/v1/proactive-assist`
- [ ] Accept: messageText, userCalendar[], conversationContext
- [ ] LangChain agent with GPT-4o-mini
- [ ] Agent has access to 3 tools:
  1. check_calendar: Find conflicts in provided calendar
  2. search_related_messages: Vector search for context
  3. suggest_alternatives: Generate alternative times
- [ ] Agent makes multi-step reasoning
- [ ] Returns structured response

### AC3: Agent Tool: check_calendar
- [ ] Input: Proposed event details (start time, end time)
- [ ] Logic: Compare proposed time range with userCalendar events using interval overlap
- [ ] Detect overlaps: `(start1 < end2) AND (start2 < end1)`
- [ ] **Default:** If event has no end time, assume 1 hour duration
- [ ] Output: List of conflicting events or "No conflicts"

### AC4: Agent Tool: search_related_messages
- [ ] Input: Search query string
- [ ] Uses Pinecone vector search
- [ ] Searches messages in current conversation
- [ ] Returns top 3 relevant messages for context
- [ ] Output: Formatted message text

### AC5: Agent Tool: suggest_alternatives
- [ ] Input: Conflict details
- [ ] Logic: Suggest times before/after conflict
- [ ] Consider conversation urgency (from context)
- [ ] Output: List of 2-3 alternative times

### AC6: Conflict Warning Modal
- [ ] User taps "⚠️ Add to calendar?"
- [ ] Modal shows:
  - "⚠️ Scheduling Conflict" header
  - "This conflicts with: [Event Name] at [Time]"
  - Agent's reasoning (brief)
  - Suggested alternatives:
    - ○ Change to 2:00 PM
    - ○ Change to 4:30 PM
    - ○ Create anyway
  - [Cancel] [Confirm Choice] buttons

### AC7: Alternative Selection
- [ ] User selects an alternative time
- [ ] Modal updates with new time
- [ ] "Create Event" proceeds with selected time
- [ ] User selects "Create anyway"
- [ ] Creates event despite conflict (user override)

### AC8: Agent Response Quality
- [ ] Agent provides concise reasoning
- [ ] Reasoning mentions specific conflict
- [ ] Suggestions are practical (within same day or adjacent)
- [ ] Agent uses conversation context when available
- [ ] Response generated in < 5 seconds

### AC9: Edge Cases
- [ ] No calendar events: Agent confirms "No conflicts"
- [ ] Multiple conflicts: Shows all, prioritizes by proximity
- [ ] Vague time ("afternoon"): Agent requests clarification or suggests broad window
- [ ] Weekend vs weekday: Agent suggests appropriate alternatives
- [ ] Offline: Conflict detection disabled, standard event creation

---

## Tasks

### Task 0: Event Schema Migration (BREAKING CHANGE)
- [ ] **Database Wipe Required:** Delete all Firestore collections before starting
- [ ] Update Event Firestore schema:
  ```typescript
  interface Event {
    // OLD: time: string  // "15:00" - REMOVED
    // NEW:
    startTime: string   // "15:00"
    endTime: string     // "17:00"
    duration: number    // 120 (minutes)
  }
  ```
- [ ] Update backend AI extraction prompt to detect `startTime` and `endTime`
- [ ] **CRITICAL Default Logic:** If `endTime` not mentioned in message, ALWAYS set to `startTime + 1 hour`
- [ ] Store duration in minutes (calculated from start/end)
- [ ] Examples:
  - "Coffee at 3pm" → startTime: "15:00", endTime: "16:00", duration: 60
  - "Meeting 2pm to 4pm" → startTime: "14:00", endTime: "16:00", duration: 120
  - "Lunch tomorrow" → startTime: "12:00", endTime: "13:00", duration: 60 (default)

### Task 0.5: iOS - EventService Updates
- [ ] Update `EventService.createEvent()` to accept `startTime`, `endTime`, `duration`
- [ ] Remove `time` parameter (breaking change)
- [ ] Add duration calculation helper: `calculateDuration(start, end)`
- [ ] Update all event creation calls throughout app

### Task 0.6: iOS - Event Creation Modal UI Updates
- [ ] Update `EventCreationModal` to include end time picker
- [ ] Add "Start Time" and "End Time" pickers (replace single "Time" picker)
- [ ] OR add duration picker with presets: [30min, 1hr, 2hr, 3hr, 4hr, All Day]
- [ ] **Default behavior:** When start time selected, auto-set end time to +1 hour
- [ ] Auto-calculate end time from start + duration
- [ ] Validate: end time must be after start time
- [ ] Update modal preview to show time range: "3:00 PM - 5:00 PM"

### Task 0.7: iOS - Event Details View Updates
- [ ] Update `EventDetailView` to display time range
- [ ] Format: "3:00 PM - 5:00 PM" (not just "3:00 PM")
- [ ] Show duration: "(2 hours)" or "(30 minutes)"
- [ ] Update quick info display in calendar cards

### Task 0.8: iOS - Calendar View Updates
- [ ] Update event list items to show time ranges
- [ ] Format: "Coffee • 3:00 PM - 4:00 PM"
- [ ] Update day view to show duration bars (optional visual enhancement)
- [ ] Ensure all event displays use new time range format

### Task 0.9: iOS - Event Confirmation Flow Updates
- [ ] When AI detects event, confirmation button shows time range
- [ ] Update "Add to calendar?" prompt to display "3:00 PM - 5:00 PM"
- [ ] Pre-fill creation modal with detected start/end times
- [ ] Update all event-related notifications to show time ranges

### Task 1: Backend - Agent Setup (AC2)
- [ ] Create `app/services/agent_service.py`
- [ ] Import LangChain components:
  - ChatOpenAI
  - create_openai_functions_agent
  - AgentExecutor
  - Tool
- [ ] Define system prompt for scheduling assistant
- [ ] Initialize agent with tools
- [ ] Set max_iterations=3 to avoid long runs

### Task 2: Backend - Tool: check_calendar (AC3)
- [ ] Implement `check_calendar` function
- [ ] Parse proposed event with start and end times
- [ ] Iterate through userCalendar events
- [ ] **Detect interval overlaps** using: `(start1 < end2) AND (start2 < end1)`
- [ ] Handle time parsing (convert to comparable format)
- [ ] Return formatted conflict list with time ranges

### Task 3: Backend - Tool: search_related_messages (AC4)
- [ ] Implement `search_related_messages` function
- [ ] Use existing VectorStoreService
- [ ] Search Pinecone namespace "messages"
- [ ] Filter by conversationId
- [ ] Return top 3 results as formatted string

### Task 4: Backend - Tool: suggest_alternatives (AC5)
- [ ] Implement `suggest_alternatives` function
- [ ] Logic: If conflict at 3pm, suggest 2pm and 4pm
- [ ] Consider time of day (don't suggest 11pm)
- [ ] Return list of alternative time strings

### Task 5: Backend - Agent Endpoint (AC2, AC8)
- [ ] Create `app/routes/agent.py`
- [ ] `POST /proactive-assist` endpoint
- [ ] Accept AgentRequest model
- [ ] Call agent_service.analyze()
- [ ] Parse agent output to structured response
- [ ] Return AgentResponse model
- [ ] Handle agent errors gracefully

### Task 6: iOS - Conflict Warning Integration (AC1)
- [ ] When event detected, check for conflicts
- [ ] If user's calendar passed to backend includes overlap:
  - AI response includes conflict=true
  - Show "⚠️" icon instead of "➕"

### Task 7: iOS - Conflict Warning Modal (AC6, AC7)
- [ ] Create `ConflictWarningModal` SwiftUI view
- [ ] Display conflict details
- [ ] Show agent's reasoning
- [ ] Radio buttons for alternatives
- [ ] "Create anyway" option
- [ ] Confirm button applies selected option

### Task 8: iOS - Alternative Time Handling (AC7)
- [ ] When user selects alternative
- [ ] Update event creation with new time
- [ ] Call EventService with modified data
- [ ] Proceed as normal event creation

### Task 9: iOS - User Calendar Passing (AC1)
- [ ] When analyzing message, fetch user's upcoming events
- [ ] Convert to simple format: [{id, title, date, time}]
- [ ] Pass to backend in /analyze-message request
- [ ] Limit to next 7 days to keep payload small

### Task 10: Manual Testing (AC1-9)
- [ ] Setup: Create calendar event "Coffee at 3pm Friday"
- [ ] Test: Send "Let's meet Friday at 3pm"
  - Verify "⚠️" icon appears
  - Open modal
  - Verify shows conflict with Coffee
  - Verify suggestions (2pm, 4pm)
  - Select alternative
  - Verify event created with new time
- [ ] Test: Send "Dinner tomorrow at 7"
  - No conflicts
  - Verify "➕" icon (no warning)
- [ ] Test: Multiple conflicts
  - Verify all listed
- [ ] Test: Offline
  - Verify no conflict detection (expected)

---

## Technical Notes

### LangChain Agent Setup
```python
from langchain_openai import ChatOpenAI
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import Tool
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.2)

tools = [
    Tool(
        name="check_calendar",
        func=self._check_calendar,
        description="Check user's calendar for conflicts with proposed event"
    ),
    Tool(
        name="search_related_messages",
        func=self._search_related_messages,
        description="Search conversation history for relevant context"
    ),
    Tool(
        name="suggest_alternatives",
        func=self._suggest_alternatives,
        description="Suggest alternative meeting times around conflicts"
    )
]

prompt = ChatPromptTemplate.from_messages([
    ("system", """You are a proactive scheduling assistant.
    When user proposes a meeting time:
    1. Check calendar for conflicts
    2. Search conversation for context (urgency, importance)
    3. Suggest alternatives if conflicts exist
    Be concise and helpful."""),
    ("user", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad"),
])

agent = create_openai_functions_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools, max_iterations=3)
```

### Agent Response Structure
```python
# Agent output (natural language)
"I found a conflict with your Coffee meeting at 3pm Friday. \
Based on the conversation, this seems urgent. \
I suggest meeting at 2pm or 4:30pm instead."

# Parsed to structured response
{
    "conflict_detected": true,
    "conflicts": ["Coffee meeting at 15:00"],
    "suggestions": ["14:00", "16:30"],
    "reasoning": "Conflicts with Coffee meeting. Urgent context detected."
}
```

### Conflict Detection Logic (Interval Overlap)
```python
def _check_calendar(self, proposed_event: str) -> str:
    """
    Check for time interval overlaps using proper collision detection.
    Two intervals overlap if: (start1 < end2) AND (start2 < end1)
    
    IMPORTANT: If endTime is not specified, ALWAYS default to startTime + 1 hour.
    """
    # Parse proposed time range from natural language
    proposed = parse_event(proposed_event)  # Returns {start, end, date}
    
    # CRITICAL: Apply 1-hour default if no end time
    if not proposed.get('end'):
        proposed['end'] = add_hours(proposed['start'], 1)
    
    conflicts = []
    for event in self.calendar:
        # Check if same day
        if event['date'] != proposed['date']:
            continue
        
        # CRITICAL: Apply 1-hour default to existing events if needed
        event_end = event.get('endTime') or add_hours(event['startTime'], 1)
            
        # Interval overlap detection
        if (proposed['start'] < event_end and 
            event['startTime'] < proposed['end']):
            conflicts.append(
                f"{event['title']} ({event['startTime']} - {event_end})"
            )
    
    if conflicts:
        return f"Conflicts found: {', '.join(conflicts)}"
    return "No conflicts found"

# Example scenarios (all assume 1-hour default when not specified):
# Event 1: Coffee 3pm (→ 3pm-4pm), Proposed: Meeting 3pm (→ 3pm-4pm) → CONFLICT ✓
# Event 1: Coffee 3pm-4pm, Proposed: Meeting 3:30pm (→ 3:30pm-4:30pm) → CONFLICT ✓
# Event 1: Coffee 3pm-4pm, Proposed: Meeting 4pm (→ 4pm-5pm) → NO CONFLICT (adjacent)
# Event 1: Coffee 3pm-5pm, Proposed: Meeting 4pm (→ 4pm-5pm) → CONFLICT ✓
```

### Event Schema Updates
```typescript
// OLD Schema (Stories 5.1-5.3)
interface Event {
  id: string
  title: string
  date: Date
  time: string  // "15:00" - REMOVED
  location?: string
  // ... other fields
}

// NEW Schema (Story 5.6+)
interface Event {
  id: string
  title: string
  date: Date
  startTime: string   // "15:00"
  endTime: string     // "17:00"
  duration: number    // 120 (minutes, calculated)
  location?: string
  // ... other fields
}

// AI Extraction Response
{
  "calendar": {
    "detected": true,
    "title": "Coffee meeting",
    "date": "2025-10-31",
    "startTime": "15:00",
    "endTime": "16:00",  // If not in message, ALWAYS default to startTime + 1 hour
    "duration": 60       // Calculated from start/end
  }
}

// Examples of 1-hour default:
// Input: "Coffee at 3pm" 
//   → startTime: "15:00", endTime: "16:00", duration: 60
// Input: "Lunch tomorrow"
//   → startTime: "12:00", endTime: "13:00", duration: 60
// Input: "Meeting 2-4pm"
//   → startTime: "14:00", endTime: "16:00", duration: 120 (explicit, no default)
```

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] LangChain agent functional
- [ ] All 3 tools working
- [ ] Conflict warnings appearing
- [ ] Alternative suggestions helpful
- [ ] Agent responses < 5 seconds
- [ ] Manual testing passed
- [ ] Agent reasoning makes sense

---

## Dependencies

**Upstream:**
- Story 5.0 (Backend Foundation)
- Story 5.1 (Smart Calendar Extraction - uses event model)
- Story 5.4 (RSVP Tracking - for complete calendar data)

**Downstream:** None

---

## Testing Strategy

### Manual Test Cases (Primary Validation)

1. **Basic Conflict**
   - Existing: Coffee at 3pm
   - Propose: Meeting at 3pm
   - Expected: Warning, shows conflict, suggests 2pm/4pm

2. **No Conflict**
   - Propose: Meeting at 1pm
   - Expected: No warning, regular event creation

3. **Multiple Conflicts**
   - Existing: Coffee 3pm, Dinner 5pm
   - Propose: Meeting 3pm-6pm
   - Expected: Shows both conflicts

4. **Context-Aware**
   - Previous messages mention urgency
   - Conflict detected
   - Expected: Agent reasoning mentions urgency

5. **Alternative Selection**
   - Select "Change to 2pm"
   - Expected: Event created at 2pm

6. **User Override**
   - Select "Create anyway"
   - Expected: Event created despite conflict

### Unit Testing (Optional)
Unit tests for LangChain agent tools and conflict detection logic may be created but are not required.

**Note:** This story will rely on manual testing for end-to-end validation. Unit tests are optional and may be skipped to meet timeline constraints.

---

## Notes

- This is the "showcase" AI feature - demonstrates agent reasoning
- LangChain agent can seem "intelligent" due to tool usage
- Keep agent iterations low (max 3) to avoid slow responses
- Agent should be helpful, not annoying - only warn on real conflicts
- **CRITICAL Default:** All events without explicit end time default to 1-hour duration
- Database wipe required before starting (breaking schema change)
- Event duration enables proper interval overlap detection vs point-in-time comparison

---

## References

- Technical Spec: Section "Proactive Assistant (LangChain Agent)"
- LangChain Agents: https://python.langchain.com/docs/modules/agents/

---

**Story 5.6 demonstrates the power of LangChain agents - AI that can reason, use tools, and provide proactive assistance.**

---

## Schema Migration Summary

**Breaking Change:** Event model updated to support time ranges (startTime/endTime) instead of single time points.

**Key Changes:**
1. ✅ Event schema: `time` → `startTime`, `endTime`, `duration`
2. ✅ AI extraction: Detects both start and end times
3. ✅ **1-hour default:** Events without explicit end time get `endTime = startTime + 1 hour`
4. ✅ Collision detection: Proper interval overlap (`start1 < end2 AND start2 < end1`)
5. ✅ UI updates: All event displays show time ranges ("3:00 PM - 5:00 PM")

**Migration Required:**
- Delete all Firestore collections (or at minimum `/events` collection)
- Story 5.6 implements new schema from scratch
- All existing event-related code updated to use new fields

**Story Points:** 7 (was 6) - Added scope for schema migration + UI updates

