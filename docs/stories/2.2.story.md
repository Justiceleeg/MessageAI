# Story 2.2: Send & Receive Real-time 1:1 Messages

## Status

Draft

## Story

**As a** user,
**I want** to send and receive messages in a 1:1 chat,
**so that** I can communicate with another user.

## Acceptance Criteria

1. When a user opens a Chat View for an existing conversation, they see the message history for that conversation (FR1).
2. When a user opens a Chat View for a new conversation (from Story 2.0), they see an empty state with the message input bar enabled.
3. Messages sent by the current user are displayed on one side (e.g., right), and messages from the other user are on the other (e.g., left).
4. A user can type text into an input field and tap "Send".
5. For existing conversations, the sent message is immediately saved to the Firestore messages sub-collection for that conversation.
6. For new conversations (first message), the system creates the conversation document AND the message atomically using a Firestore batch write.
7. After sending the first message in a new conversation, subsequent messages are sent normally to the created conversation.
8. Any new message received in this conversation appears at the bottom of the chat history in real-time (FR2).
9. Every message displayed in the chat history includes a human-readable timestamp (e.g., "10:30 AM") (FR5).

## Tasks / Subtasks

- [ ] Task 1: Create Message Data Models (AC: 1, 2, 6)
  - [ ] Create Message model in `ios-app/MessageAI/Models/Message.swift`
  - [ ] Define properties matching Firestore schema: messageId (String), senderId (String), text (String), timestamp (Date), status (String enum: "sending", "sent", "delivered", "read")
  - [ ] Make model Identifiable and Codable for Firestore integration
  - [ ] Add computed property `isSentByCurrentUser(currentUserId: String) -> Bool` for UI layout
  - [ ] Create SwiftData MessageEntity model in `ios-app/MessageAI/Models/MessageEntity.swift` for local caching
  - [ ] Define same properties as Message model using SwiftData @Model attribute
  - [ ] Add relationship to ConversationEntity (belongs-to relationship)
  - [ ] Update PersistenceController to include MessageEntity in ModelContainer

- [ ] Task 2: Extend FirestoreService for Message Operations (AC: 1, 4, 5)
  - [ ] Open existing `ios-app/MessageAI/Services/FirestoreService.swift`
  - [ ] Implement `listenToMessages(conversationId: String) -> AsyncThrowingStream<[Message], Error>` method
  - [ ] Use Firestore query: `conversations/{conversationId}/messages` sub-collection
  - [ ] Order by `timestamp` ascending (oldest first, chronological order)
  - [ ] Use Firestore snapshot listener for real-time updates (`.addSnapshotListener`)
  - [ ] Map Firestore documents to Message model
  - [ ] Implement `sendMessage(conversationId: String, senderId: String, text: String) async throws -> Message` method
  - [ ] Generate new messageId (UUID or Firestore auto-generated)
  - [ ] Create Message object with status "sending"
  - [ ] Write to Firestore `conversations/{conversationId}/messages` sub-collection
  - [ ] Update parent conversation document with lastMessageText and lastMessageTimestamp
  - [ ] Handle Firestore errors with proper error propagation
  - [ ] Add unit tests in `ios-app/MessageAITests/FirestoreServiceTests.swift`

- [ ] Task 3: Create ChatViewModel (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9)
  - [ ] Create `ios-app/MessageAI/ViewModels/ChatViewModel.swift`
  - [ ] Implement ChatViewModel as ObservableObject
  - [ ] Inject FirestoreService and AuthService dependencies
  - [ ] Add @Published property `messages: [Message] = []`
  - [ ] Add @Published property `messageText: String = ""` for input field binding
  - [ ] Add @Published property `isLoading: Bool = false`
  - [ ] Add @Published property `isSending: Bool = false`
  - [ ] Add @Published property `errorMessage: String?`
  - [ ] Add @Published property `conversationId: String?` (may be nil for new chats)
  - [ ] Add property `otherUserId: String` (passed in initializer)
  - [ ] Add property `participants: [String]` derived from currentUserId and otherUserId
  - [ ] Implement `loadMessages()` method that:
    - Only starts listener if conversationId is not nil
    - Calls FirestoreService.listenToMessages()
    - Updates @Published messages array when Firestore emits changes
    - Handles errors and updates errorMessage
  - [ ] Implement `sendMessage()` method that:
    - Validates messageText is not empty
    - Gets currentUser from AuthService
    - Checks if conversationId is nil (new conversation)
    - If nil: Calls FirestoreService.createConversationWithMessage() (from Story 2.0)
    - If nil: Updates conversationId with newly created ID
    - If not nil: Calls FirestoreService.sendMessage() (existing conversation)
    - Clears messageText after sending
    - Updates isSending state
    - Handles errors
  - [ ] Implement `onAppear()` lifecycle method to start listening to messages (if conversationId exists)
  - [ ] Implement `onDisappear()` lifecycle method to stop listening
  - [ ] Add unit tests in `ios-app/MessageAITests/ChatViewModelTests.swift`

- [ ] Task 4: Build Chat View UI (AC: 1, 2, 3, 4, 9)
  - [ ] Update placeholder `ios-app/MessageAI/Views/Chat/ChatView.swift` (created in Story 2.1)
  - [ ] Inject ChatViewModel via @StateObject
  - [ ] Pass conversationId (optional) and otherUserId from navigation (ConversationListView or UserSearchView)
  - [ ] Handle both existing conversations (conversationId provided) and new chats (conversationId nil)
  - [ ] Implement message list UI using ScrollView or List
  - [ ] Display messages in chronological order (oldest at top, newest at bottom)
  - [ ] Implement message bubble layout:
    - Current user messages: Right-aligned, blue bubbles
    - Other user messages: Left-aligned, gray bubbles
  - [ ] Each message bubble shows:
    - Message text (wrapping, dynamic height)
    - Timestamp below message (small, gray text)
  - [ ] Auto-scroll to bottom when new message arrives
  - [ ] Show empty state when messages array is empty: "Start the conversation"
  - [ ] Show loading spinner when isLoading is true (only for existing conversations)
  - [ ] Implement message input bar at bottom:
    - TextField for message text (multiline, dynamic height up to 5 lines)
    - Send button (SF Symbol `arrow.up.circle.fill`, blue, 36pt)
    - Send button disabled when messageText is empty
  - [ ] Bind TextField to ChatViewModel.messageText
  - [ ] Bind Send button action to ChatViewModel.sendMessage()
  - [ ] Set navigation title to other user's display name
  - [ ] Follow iOS Messages app design patterns
  - [ ] Add accessibility labels for VoiceOver
  - [ ] Add SwiftUI Preview with mock data

- [ ] Task 5: Implement Message Bubble Component (AC: 2, 6)
  - [ ] Create reusable `ios-app/MessageAI/Views/Chat/MessageBubbleView.swift` component
  - [ ] Accept Message and isSentByCurrentUser as parameters
  - [ ] Implement bubble shape with rounded corners (16pt radius)
  - [ ] Style for sent messages:
    - Background: System blue color
    - Text: White
    - Alignment: Right (HStack with Spacer on left)
    - Padding: 12pt horizontal, 8pt vertical
  - [ ] Style for received messages:
    - Background: System gray (secondary background)
    - Text: Primary label color
    - Alignment: Left (HStack with Spacer on right)
    - Padding: 12pt horizontal, 8pt vertical
  - [ ] Display timestamp below bubble:
    - Format: "10:30 AM" using DateFormatter
    - Font: SF Pro Text, 11pt, gray
    - Alignment: Match bubble alignment (right for sent, left for received)
  - [ ] Support multiline text with proper wrapping
  - [ ] Maximum bubble width: ~70% of screen width
  - [ ] Add SwiftUI Preview

- [ ] Task 6: Implement Message Input Bar Component (AC: 3)
  - [ ] Create reusable `ios-app/MessageAI/Views/Chat/MessageInputBar.swift` component
  - [ ] Accept @Binding<String> for message text and send action closure
  - [ ] Implement layout:
    - HStack with TextField and Send button
    - TextField with rounded border, padding
    - TextField placeholder: "Message"
    - TextField multiline support (up to 5 lines)
    - Send button: SF Symbol `arrow.up.circle.fill`, 36pt
  - [ ] Disable send button when text is empty or whitespace-only
  - [ ] Handle keyboard: TextField focused automatically when view appears
  - [ ] Dismiss keyboard after sending message
  - [ ] Style: Match iOS Messages input bar
  - [ ] Accessibility: VoiceOver labels for TextField and button
  - [ ] Add SwiftUI Preview

- [ ] Task 7: Implement Real-Time Message Updates (AC: 5)
  - [ ] Verify Firestore snapshot listener in FirestoreService emits updates to AsyncThrowingStream
  - [ ] Test that ChatViewModel receives real-time message updates
  - [ ] Test that SwiftUI updates message list when @Published messages changes
  - [ ] Implement auto-scroll to bottom when new message arrives
  - [ ] Use ScrollViewReader with .scrollTo() to scroll to latest message
  - [ ] Test that sent messages appear immediately in UI
  - [ ] Test that received messages appear in real-time

- [ ] Task 8: Implement Auto-Scroll to Bottom (AC: 5)
  - [ ] Use ScrollViewReader to wrap message list
  - [ ] Add .id() to last message view
  - [ ] In .onChange(of: messages) modifier, call scrollTo(lastMessageId, anchor: .bottom)
  - [ ] Add animation for smooth scrolling
  - [ ] Scroll to bottom when view first appears
  - [ ] Scroll to bottom when new message is sent
  - [ ] Scroll to bottom when new message is received

- [ ] Task 9: Update Conversation Metadata on Message Send (AC: 4)
  - [ ] In FirestoreService.sendMessage(), update parent conversation document
  - [ ] Set `lastMessageText` to message text (or "You: {text}" prefix)
  - [ ] Set `lastMessageTimestamp` to current timestamp
  - [ ] Use Firestore transaction or batch write for atomicity
  - [ ] Ensure conversation list updates in real-time (Story 2.1 listener picks this up)
  - [ ] Test that sending message updates conversation preview in list

- [ ] Task 10: Format Message Timestamps (AC: 6)
  - [ ] Reuse or extend DateFormatters utility from Story 2.1
  - [ ] Format timestamps as "10:30 AM" for messages
  - [ ] Optional: Show date headers for messages from different days ("Today", "Yesterday", "Oct 15")
  - [ ] Apply formatting in MessageBubbleView
  - [ ] Test timestamp formatting for edge cases (midnight, different timezones)

- [ ] Task 11: Fetch Other User's Display Name (AC: 1)
  - [ ] In ChatViewModel, fetch other user's display name using FirestoreService.fetchUser()
  - [ ] Store display name in @Published property for navigation title
  - [ ] Handle case where user not found (show userId or "Unknown User")
  - [ ] Cache user data to avoid repeated fetches
  - [ ] Display display name in navigation bar title

- [ ] Task 12: Handle Empty Message History (AC: 1, 2)
  - [ ] Display empty state when messages array is empty
  - [ ] For existing conversations: Show "No messages yet"
  - [ ] For new conversations (conversationId nil): Show "Start the conversation" or "Say hi to [Name]"
  - [ ] Optional: Add hint text like "Send a message to start the conversation"
  - [ ] Empty state should not interfere with message input bar
  - [ ] Message input bar should be enabled and functional in empty state

- [ ] Task 13: Local Caching with SwiftData (AC: 1)
  - [ ] Update ChatViewModel to save messages to SwiftData
  - [ ] Load cached messages from SwiftData on view appear (before Firestore data arrives)
  - [ ] Display cached data immediately for fast perceived performance
  - [ ] Update SwiftData cache when Firestore data changes
  - [ ] Associate MessageEntity with ConversationEntity using relationship
  - [ ] Handle SwiftData operations on background thread using ModelContext
  - [ ] Test that messages persist across app restarts

- [ ] Task 14: Integration Testing (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9)
  - [ ] Create integration tests in `ios-app/MessageAITests/ChatViewIntegrationTests.swift`
  - [ ] Test loading message history from Firestore (existing conversation)
  - [ ] Test opening new conversation with nil conversationId (empty state)
  - [ ] Test sending first message in new conversation (creates conversation + message)
  - [ ] Test conversationId is updated after first message sent
  - [ ] Test sending subsequent messages after conversation created
  - [ ] Test sending message in existing conversation
  - [ ] Test sending message updates parent conversation document
  - [ ] Test real-time updates when another user sends a message
  - [ ] Test message layout (sent vs received alignment)
  - [ ] Test timestamp display on messages
  - [ ] Test auto-scroll to bottom on new message
  - [ ] Test empty state when no messages exist (both new and existing conversations)
  - [ ] Test error handling when Firestore operations fail
  - [ ] Test error handling when conversation creation fails
  - [ ] Test caching and offline data loading
  - [ ] Use Firebase Local Emulator Suite for testing (or mock Firestore)

## Dev Notes

### Previous Story Insights

**From Epic 1 (Stories 1.1, 1.2, 1.3):**
- Firebase SDK integrated (Auth, Firestore, FirestoreSwift)
- AuthService provides currentUser state
- FirestoreService exists for user and conversation operations
- Navigation routing with NavigationStack established
- SwiftData persistence layer configured
- Testing infrastructure with XCTest established

**From Story 2.1:**
- Conversation data models created (Conversation, ConversationEntity)
- FirestoreService extended with conversation fetching and real-time listeners
- ConversationListViewModel manages conversation list state
- ConversationListView displays list of conversations
- Navigation to ChatView implemented (with conversationId)
- DateFormatters utility created for timestamp formatting
- Real-time Firestore snapshot listeners working

**From Story 2.0:**
- User search functionality implemented
- Lazy conversation creation pattern established
- FirestoreService.createConversationWithMessage() method created
- Navigation to ChatView can pass nil conversationId for new chats
- Conversation only created when first message is sent

**Key Technical Foundation Built:**
✓ Real-time Firestore queries with snapshot listeners  
✓ MVVM architecture with ViewModels  
✓ SwiftData relationships (ConversationEntity → MessageEntity)  
✓ Date/time formatting utilities  
✓ Navigation to detail views  
✓ Empty state handling  

**This Story Builds:**
- First implementation of sub-collection queries (messages within conversations)
- Bi-directional chat UI with message bubbles
- Message input with real-time sending
- Auto-scroll to bottom on new messages
- Update parent document on child creation (conversation metadata)
- More complex SwiftUI layouts (chat interface)
- **Handling optional conversationId** (nil for new chats, non-nil for existing)
- **Lazy conversation creation on first message send** (integration with Story 2.0)

### UI/UX Specification

**IMPORTANT**: Follow native iOS Messages app design patterns

**Chat View Screen Design:**

- **Navigation Bar:**
  - Title: Other user's display name (SF Pro Display, bold, 17pt)
  - Leading button: Back button (automatic with NavigationStack)
  - Trailing button: None for MVP (future: call, video, info)
  - Background: System background color

- **Message List Layout:**
  - ScrollView or List displaying messages chronologically (oldest at top)
  - Messages grouped by sender with appropriate alignment
  - Background: Light gray (system grouped background) or white
  - Padding: 8pt horizontal, 4pt vertical between messages
  - Auto-scroll to bottom when new message arrives
  - Pull-to-refresh: None for MVP (all data real-time)

- **Message Bubble Design:**
  
  **Sent Messages (Current User):**
  ```
                      Hello! How are you?
                                 10:30 AM
  ```
  - Alignment: Right side of screen
  - Background: System blue (#007AFF or iOS accent color)
  - Text color: White
  - Font: SF Pro Text, 16pt, regular
  - Padding: 12pt horizontal, 8pt vertical
  - Corner radius: 18pt (rounded corners)
  - Max width: 70% of screen width
  - Tail: Optional rounded tail pointing right (can omit for simplicity)
  - Timestamp: Below bubble, right-aligned, 11pt gray text
  
  **Received Messages (Other User):**
  ```
  I'm doing great, thanks!
  10:31 AM
  ```
  - Alignment: Left side of screen
  - Background: System gray (light gray in light mode, dark gray in dark mode)
  - Text color: Primary label (black in light mode, white in dark mode)
  - Font: SF Pro Text, 16pt, regular
  - Padding: 12pt horizontal, 8pt vertical
  - Corner radius: 18pt (rounded corners)
  - Max width: 70% of screen width
  - Tail: Optional rounded tail pointing left (can omit for simplicity)
  - Timestamp: Below bubble, left-aligned, 11pt gray text

- **Message Input Bar:**
  ```
  [  Type a message...                      ] [↑]
  ```
  - Position: Bottom of screen (above keyboard)
  - Background: System background with top border
  - Layout: HStack with TextField and Send button
  - **TextField:**
    - Placeholder: "Message" or "Type a message..."
    - Background: Light gray rounded rectangle
    - Corner radius: 18pt
    - Padding: 8pt horizontal, 8pt vertical
    - Multiline: Yes, expands up to 5 lines
    - Dynamic height based on content
    - Font: SF Pro Text, 16pt
  - **Send Button:**
    - Icon: SF Symbol `arrow.up.circle.fill`
    - Size: 36pt
    - Color: System blue when enabled, gray when disabled
    - Position: Trailing edge of input bar
    - Action: Send message and clear text field
    - Disabled: When text field is empty or whitespace-only
  - Keyboard handling: Input bar moves up with keyboard
  - Safe area: Respects bottom safe area (iPhone notch)

- **Empty State:**
  - Centered vertically in message area
  - SF Symbol: `bubble.left.and.bubble.right` (gray, 60pt)
  - **For existing conversations:** Text: "No messages yet" (SF Pro Text, 17pt, gray)
  - **For new conversations:** Text: "Start the conversation" or "Say hi to [Name]" (SF Pro Text, 17pt, gray)
  - Subtitle: "Send a message to start chatting" (SF Pro Text, 15pt, light gray)
  - Message input bar remains visible and enabled

- **Loading State:**
  - Show ProgressView (spinner) centered while loading message history
  - OR show skeleton loading bubbles (gray placeholders)

- **Sending State:**
  - Show message bubble immediately with "sending..." indicator (optional)
  - OR show subtle animation on send button (loading spinner)

**Date Headers (Optional Enhancement):**
- Group messages by date with header rows
- Format: "Today", "Yesterday", "Monday, Oct 15"
- Centered in message list
- Font: SF Pro Text, 13pt, bold, gray
- Background: Subtle gray pill shape (optional)

**Accessibility Requirements:**
- VoiceOver labels: "Message from [Name]: [text], sent at [time]"
- VoiceOver hint on Send button: "Send message"
- Dynamic Type support: All text scales with system settings
- Minimum touch target: 44pt for send button
- High contrast mode: Ensure bubble colors have sufficient contrast
- Reduce Motion: No animations when preference is enabled

**Animations:**
- New message appear: Fade in + slide up (0.2s ease-out)
- Scroll to bottom: Smooth animated scroll (0.3s ease-in-out)
- Send button: Subtle scale effect on tap (0.1s)
- Input bar: Smooth keyboard animation (system default)

**Key UI Decisions:**
- Simple bubble design without complex tails (easier to implement, still looks great)
- Auto-scroll to bottom for best UX (user always sees latest message)
- Minimal chrome (no timestamps between every message, just below each bubble)
- Native iOS keyboard handling (SwiftUI handles this automatically)
- Focus on clarity and readability over decorative elements

### Architecture Context

**Tech Stack** [Source: architecture/tech-stack.md]
- Frontend: Swift 5.9+, SwiftUI (Latest), Native SwiftUI Components
- State Management: SwiftUI built-in (@State, @StateObject, @ObservedObject, @EnvironmentObject)
- Database: Firebase Firestore (Remote), SwiftData (iOS 17+ for local cache)
- Real-time Updates: Firestore snapshot listeners
- Testing: XCTest for unit/UI testing

**Project Structure** [Source: architecture/unified-project-structure.md]
```
ios-app/
├── MessageAI/
│   ├── Models/
│   │   ├── Message.swift (NEW)
│   │   ├── MessageEntity.swift (NEW)
│   │   ├── Conversation.swift (existing from Story 2.1)
│   │   ├── ConversationEntity.swift (existing from Story 2.1)
│   │   ├── User.swift (existing)
│   │   └── UserEntity.swift (existing)
│   ├── Views/
│   │   ├── Chat/
│   │   │   ├── ChatView.swift (UPDATE - replace placeholder)
│   │   │   ├── MessageBubbleView.swift (NEW)
│   │   │   └── MessageInputBar.swift (NEW)
│   │   ├── Conversations/ (existing)
│   │   ├── Settings/ (existing)
│   │   └── Auth/ (existing)
│   ├── ViewModels/
│   │   ├── ChatViewModel.swift (NEW)
│   │   ├── ConversationListViewModel.swift (existing)
│   │   └── AuthViewModel.swift (existing)
│   ├── Services/
│   │   ├── FirestoreService.swift (UPDATE - add message methods)
│   │   └── AuthService.swift (existing)
│   ├── Utilities/
│   │   └── DateFormatters.swift (UPDATE - add message timestamp format)
│   └── Persistence/
│       └── PersistenceController.swift (UPDATE - add MessageEntity)
├── MessageAI.xcodeproj
└── MessageAITests/
    ├── ChatViewModelTests.swift (NEW)
    ├── ChatViewIntegrationTests.swift (NEW)
    └── FirestoreServiceTests.swift (UPDATE)
```

**Data Models** [Source: architecture/data-models.md, database-schema.md]

Message Model (Swift):
```swift
struct Message: Identifiable, Codable {
    let id: String  // messageId
    let messageId: String
    let senderId: String
    let text: String
    let timestamp: Date
    var status: String  // "sending", "sent", "delivered", "read"
    
    // Helper to determine message alignment in UI
    func isSentByCurrentUser(currentUserId: String) -> Bool {
        return senderId == currentUserId
    }
}
```

MessageEntity (SwiftData):
```swift
@Model
final class MessageEntity {
    @Attribute(.unique) var messageId: String
    var senderId: String
    var text: String
    var timestamp: Date
    var status: String  // "sending", "sent", "delivered", "read"
    var conversation: ConversationEntity?
    
    init(messageId: String, senderId: String, text: String, 
         timestamp: Date, status: String = "sending", 
         conversation: ConversationEntity? = nil) {
        self.messageId = messageId
        self.senderId = senderId
        self.text = text
        self.timestamp = timestamp
        self.status = status
        self.conversation = conversation
    }
}
```

**Firestore Schema** [Source: architecture/database-schema.md]

**messages Sub-collection (within conversations):**
- Document ID: Auto-generated (e.g., "msg_abc123")
- Parent: `conversations/{conversationId}/messages`
- Fields:
  - `senderId`: string - userId of message sender
  - `text`: string - Message content
  - `timestamp`: timestamp - When message was sent
  - `status`: string - Delivery status ("sending", "sent", "delivered", "read")
- Indexes:
  - `timestamp` (ascending) - For chronological ordering
  - Composite: `senderId` + `timestamp` (optional, for sender-specific queries)

**Firestore Queries:**

Listen to messages in conversation:
```swift
db.collection("conversations").document(conversationId)
  .collection("messages")
  .order(by: "timestamp", ascending: true)
  .addSnapshotListener { snapshot, error in
      // Handle real-time updates
  }
```

Send new message:
```swift
let messageData: [String: Any] = [
    "messageId": messageId,
    "senderId": senderId,
    "text": text,
    "timestamp": FieldValue.serverTimestamp(),
    "status": "sent"
]

db.collection("conversations").document(conversationId)
  .collection("messages")
  .document(messageId)
  .setData(messageData)

// Also update parent conversation
db.collection("conversations").document(conversationId)
  .updateData([
      "lastMessageText": text,
      "lastMessageTimestamp": FieldValue.serverTimestamp()
  ])
```

**FirestoreService Extension Template:**
```swift
import FirebaseFirestore
import FirebaseFirestoreSwift

class FirestoreService: ObservableObject {
    private let db = Firestore.firestore()
    
    // Existing methods from Stories 1.1, 2.1
    
    // NEW: Listen to messages in a conversation
    func listenToMessages(conversationId: String) -> AsyncThrowingStream<[Message], Error> {
        AsyncThrowingStream { continuation in
            let listener = db.collection("conversations")
                .document(conversationId)
                .collection("messages")
                .order(by: "timestamp", ascending: true)
                .addSnapshotListener { snapshot, error in
                    if let error = error {
                        continuation.finish(throwing: error)
                        return
                    }
                    
                    guard let documents = snapshot?.documents else {
                        continuation.yield([])
                        return
                    }
                    
                    let messages = documents.compactMap { doc -> Message? in
                        try? doc.data(as: Message.self)
                    }
                    continuation.yield(messages)
                }
            
            continuation.onTermination = { _ in
                listener.remove()
            }
        }
    }
    
    // NEW: Send a message
    func sendMessage(conversationId: String, senderId: String, text: String) async throws -> Message {
        let messageId = UUID().uuidString
        let message = Message(
            id: messageId,
            messageId: messageId,
            senderId: senderId,
            text: text,
            timestamp: Date(),
            status: "sent"
        )
        
        // Write message to sub-collection
        try await db.collection("conversations")
            .document(conversationId)
            .collection("messages")
            .document(messageId)
            .setData([
                "messageId": messageId,
                "senderId": senderId,
                "text": text,
                "timestamp": FieldValue.serverTimestamp(),
                "status": "sent"
            ])
        
        // Update parent conversation
        try await db.collection("conversations")
            .document(conversationId)
            .updateData([
                "lastMessageText": text,
                "lastMessageTimestamp": FieldValue.serverTimestamp()
            ])
        
        return message
    }
}
```

**State Management** [Source: architecture/frontend-architecture.md#State-Management-Architecture]
- ChatViewModel as ObservableObject with @Published properties
- Inject into view via @StateObject
- Real-time updates from Firestore trigger @Published changes, SwiftUI auto-updates UI
- SwiftData cache provides instant initial load, then Firestore updates override

**Data Flow:**

**For Existing Conversations:**
1. User navigates to ChatView from ConversationListView (conversationId provided)
2. ChatView creates ChatViewModel with conversationId and otherUserId
3. ViewModel loads messages from SwiftData cache (fast, instant UI)
4. ViewModel starts Firestore snapshot listener for messages
5. Firestore emits initial data → ViewModel updates @Published messages
6. SwiftUI message list rerenders with Firestore data
7. User types message and taps Send
8. ViewModel calls FirestoreService.sendMessage()
9. Message written to Firestore → Firestore listener emits update
10. ViewModel receives update → @Published messages updates → UI shows new message
11. Auto-scroll to bottom of message list

**For New Conversations (from Story 2.0):**
1. User navigates to ChatView from UserSearchView (conversationId = nil, otherUserId provided)
2. ChatView creates ChatViewModel with conversationId = nil and otherUserId
3. ViewModel shows empty state (no messages to load, no listener started)
4. User types first message and taps Send
5. ViewModel detects conversationId is nil
6. ViewModel calls FirestoreService.createConversationWithMessage() (creates conversation + message atomically)
7. ViewModel updates conversationId with newly created ID
8. ViewModel starts Firestore snapshot listener for messages
9. Message appears in UI (from Firestore listener)
10. Subsequent messages use normal sendMessage() flow
11. New conversation appears in conversation list (via real-time listener in Story 2.1)

**Routing** [Source: architecture/frontend-architecture.md#Routing-Architecture]
- Use NavigationStack (iOS 16+) from root app view
- Navigation from ConversationListView to ChatView via NavigationLink
- Pass conversationId and otherUserId as parameters
- Navigation title shows other user's display name
- Back button returns to conversation list

**Error Handling** [Source: architecture/error-handling-strategy.md#Frontend-Error-Handling]
- Use do-catch for async/await service calls
- AsyncThrowingStream propagates Firestore errors
- ViewModels catch errors, log using OSLog
- Update @Published errorMessage for UI display
- Display user-friendly error messages via Alert or banner

**Common Error Messages:**
- Send message fails: "Failed to send message. Please try again."
- Create conversation fails (first message): "Failed to start conversation. Please try again."
- Network error: "No internet connection. Your message will be sent when you reconnect."
- Firestore query fails: "Unable to load messages. Please try again."
- Permission denied: "Unable to access this conversation."
- Empty message: "Please enter a message before sending."

**Coding Standards** [Source: architecture/coding-standards.md]
- Files: PascalCase (e.g., `Message.swift`, `ChatViewModel.swift`, `MessageBubbleView.swift`)
- Models: PascalCase (e.g., `Message`, `MessageEntity`)
- Functions/Methods: camelCase (e.g., `sendMessage()`, `listenToMessages()`)
- Variables: camelCase (e.g., `messageId`, `messageText`)
- Use official Firebase SDKs
- Consistent error handling: Swift do-catch/async-await patterns
- Use SwiftData on background threads
- Rely on Firestore Security Rules

**SwiftUI Best Practices:**
- Extract reusable components (MessageBubbleView, MessageInputBar)
- Use @Binding for two-way data flow (input text)
- Use ScrollViewReader for programmatic scrolling
- Use .onChange modifier for reactive updates
- Keep View files focused and readable
- Separate presentation logic from business logic (ViewModel)

**Firestore Sub-Collections:**
- Messages stored as sub-collection within conversations
- Path: `conversations/{conversationId}/messages/{messageId}`
- Allows efficient querying of messages per conversation
- Firestore Security Rules apply to sub-collections separately

**Firestore Security Rules:**
```javascript
// Messages: Users can read messages in conversations they participate in
match /conversations/{conversationId}/messages/{messageId} {
  allow read: if request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
  allow create: if request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants
                && request.auth.uid == request.resource.data.senderId;
}
```

### Testing

**Testing Standards** [Source: architecture/testing-strategy.md]

**Test Organization:**
- Unit tests location: `ios-app/MessageAITests/`
- Integration tests: Same location, separate files
- Use Firebase Local Emulator Suite for Firestore integration tests (optional)

**Frontend Testing:**
- Framework: XCTest (Native iOS testing framework)
- Unit tests for ViewModels: Mock FirestoreService, test business logic
- Unit tests for Services: Mock Firestore SDK or use emulator
- Integration tests: Test complete flow from Firestore to UI
- Test naming convention: `test{MethodName}_{Scenario}_{ExpectedResult}`

**Testing Requirements for This Story:**

1. **FirestoreService unit tests:**
   - Test listenToMessages() returns AsyncThrowingStream
   - Test messages ordered by timestamp ascending
   - Test snapshot listener emits updates when new message arrives
   - Test sendMessage() writes to Firestore messages sub-collection
   - Test sendMessage() updates parent conversation document
   - Test sendMessage() returns Message object
   - Test error handling when Firestore operations fail
   - Mock Firestore or use emulator

2. **ChatViewModel unit tests:**
   - Test loadMessages() fetches data from FirestoreService (existing conversation)
   - Test loadMessages() does NOT start listener when conversationId is nil (new conversation)
   - Test @Published messages updates when Firestore emits data
   - Test sendMessage() validates non-empty text
   - Test sendMessage() with existing conversationId calls FirestoreService.sendMessage()
   - Test sendMessage() with nil conversationId calls FirestoreService.createConversationWithMessage()
   - Test sendMessage() updates conversationId after creating new conversation
   - Test sendMessage() clears messageText after sending
   - Test isSending state during send operation
   - Test error handling updates errorMessage
   - Test fetching other user's display name
   - Mock FirestoreService and AuthService

3. **Date formatting unit tests:**
   - Test message timestamp formats as "10:30 AM"
   - Test different time formats (AM/PM, 24-hour)
   - Test edge cases (midnight, noon, different timezones)

4. **SwiftData integration tests:**
   - Test saving messages to SwiftData
   - Test loading messages from SwiftData cache
   - Test MessageEntity relationship with ConversationEntity
   - Test updating cached data when Firestore data changes

5. **Integration tests:**
   - Test complete flow for existing conversation: User types → Send → Firestore → Real-time update
   - Test complete flow for new conversation: User types first message → Create conversation + message → Real-time update
   - Test conversationId updates after first message in new conversation
   - Test subsequent messages work normally after conversation created
   - Test message appears in sender's UI immediately
   - Test message appears in recipient's UI in real-time
   - Test conversation list updates with new message preview (both existing and new conversations)
   - Test auto-scroll to bottom on new message
   - Test empty state when no messages exist (both existing and new conversations)
   - Test error handling when send fails (existing conversation)
   - Test error handling when conversation creation fails (new conversation)
   - Use test Firestore data or emulator

6. **Manual testing checklist:**
   - [ ] Chat view displays message history on open (existing conversation)
   - [ ] Chat view displays empty state on open (new conversation)
   - [ ] Sent messages appear on right side (blue bubbles)
   - [ ] Received messages appear on left side (gray bubbles)
   - [ ] User can type in message input field
   - [ ] Send button is disabled when input is empty
   - [ ] Tapping Send sends message and clears input
   - [ ] **NEW: First message in new conversation creates conversation document**
   - [ ] **NEW: Subsequent messages after first work normally**
   - [ ] **NEW: New conversation appears in conversation list after first message**
   - [ ] Sent message appears immediately in UI
   - [ ] Message includes timestamp below bubble
   - [ ] Real-time: New message from other user appears automatically
   - [ ] Auto-scroll to bottom when new message arrives
   - [ ] Conversation list updates with latest message preview
   - [ ] Empty state displays when no messages exist
   - [ ] Loading spinner shows while fetching messages (existing conversations)
   - [ ] Error message displays when send fails
   - [ ] Error message displays when conversation creation fails (new conversation)
   - [ ] Keyboard appears when input field is focused
   - [ ] Input bar moves up with keyboard
   - [ ] VoiceOver announces messages correctly
   - [ ] Dynamic Type scales text correctly
   - [ ] Messages persist across app restarts (SwiftData cache)

**Test Example:**
```swift
// Example unit test structure
import XCTest
@testable import MessageAI

final class ChatViewModelTests: XCTestCase {
    var viewModel: ChatViewModel!
    var mockFirestoreService: MockFirestoreService!
    var mockAuthService: MockAuthService!
    let testConversationId = "conv123"
    let testOtherUserId = "user456"
    
    override func setUp() {
        super.setUp()
        mockFirestoreService = MockFirestoreService()
        mockAuthService = MockAuthService()
        mockAuthService.currentUser = User(
            userId: "user123",
            displayName: "Test User",
            presence: "online",
            lastSeen: Date()
        )
        viewModel = ChatViewModel(
            conversationId: testConversationId,
            otherUserId: testOtherUserId,
            firestoreService: mockFirestoreService,
            authService: mockAuthService
        )
    }
    
    func testSendMessage_WithExistingConversation_CallsSendMessage() async throws {
        // Arrange
        viewModel.conversationId = testConversationId  // Existing conversation
        viewModel.messageText = "Hello, world!"
        
        // Act
        await viewModel.sendMessage()
        
        // Assert
        XCTAssertTrue(mockFirestoreService.sendMessageCalled)
        XCTAssertEqual(mockFirestoreService.lastMessageText, "Hello, world!")
        XCTAssertEqual(mockFirestoreService.lastConversationId, testConversationId)
        XCTAssertTrue(viewModel.messageText.isEmpty)  // Text cleared after send
    }
    
    func testSendMessage_WithNewConversation_CreatesConversationAndMessage() async throws {
        // Arrange
        viewModel.conversationId = nil  // New conversation
        viewModel.messageText = "First message!"
        let newConversationId = "conv_new123"
        mockFirestoreService.newConversationIdToReturn = newConversationId
        
        // Act
        await viewModel.sendMessage()
        
        // Assert
        XCTAssertTrue(mockFirestoreService.createConversationWithMessageCalled)
        XCTAssertEqual(mockFirestoreService.lastMessageText, "First message!")
        XCTAssertEqual(viewModel.conversationId, newConversationId)  // Updated after creation
        XCTAssertTrue(viewModel.messageText.isEmpty)
    }
    
    func testSendMessage_WithEmptyText_DoesNotSend() async {
        // Arrange
        viewModel.messageText = "   "  // Whitespace only
        
        // Act
        await viewModel.sendMessage()
        
        // Assert
        XCTAssertFalse(mockFirestoreService.sendMessageCalled)
    }
    
    func testLoadMessages_WithValidConversation_UpdatesMessages() async throws {
        // Arrange
        let mockMessages = [
            Message(
                id: "msg1",
                messageId: "msg1",
                senderId: "user123",
                text: "Hello!",
                timestamp: Date(),
                status: "sent"
            ),
            Message(
                id: "msg2",
                messageId: "msg2",
                senderId: "user456",
                text: "Hi there!",
                timestamp: Date(),
                status: "sent"
            )
        ]
        mockFirestoreService.messagesToReturn = mockMessages
        
        // Act
        viewModel.loadMessages()
        try await Task.sleep(nanoseconds: 100_000_000)  // Wait for async update
        
        // Assert
        XCTAssertEqual(viewModel.messages.count, 2)
        XCTAssertEqual(viewModel.messages.first?.text, "Hello!")
        XCTAssertFalse(viewModel.isLoading)
    }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | SM Agent (Claude) |

## Dev Agent Record

### Agent Model Used

_To be populated by Dev Agent_

### Debug Log References

_To be populated by Dev Agent_

### Completion Notes List

_To be populated by Dev Agent_

### File List

_To be populated by Dev Agent_

## QA Results

_To be populated by QA Agent_

