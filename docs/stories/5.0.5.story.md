# Story 5.0.5: iOS Data Models & Services Foundation

**Epic:** 5 - AI-Powered Messaging Features  
**Story Points:** 3  
**Priority:** Critical  
**Assigned To:** @dev  
**Status:** Done

---

## User Story

**As a** developer,  
**I want** Swift data models and service layers for Events, Reminders, and Decisions,  
**so that** I can implement AI features that create and manage these entities.

---

## Description

Create the foundational data models and service layers required for all AI-powered features in Epic 5. This includes Swift models for Events, Reminders, and Decisions, their corresponding SwiftData entities for local persistence, and service layers for CRUD operations and Firestore synchronization.

This story is purely infrastructure - no user-facing features yet, but creates the foundation on which all subsequent AI stories depend.

**Critical Note:** Story 5.1 (Smart Calendar Extraction) cannot proceed without Event models and EventService. This story MUST be completed first.

### 🎯 The Three Models: Events, Reminders, Decisions

This story creates data models for three distinct AI features:

**📅 Event Model** (Story 5.1)
- Represents social gatherings, meetings, appointments
- Has date/time, location, attendees
- Example: "Dinner Friday 7pm"

**⏰ Reminder Model** (Story 5.5)
- Represents personal tasks with deadlines
- Has due date, completion status, notification ID
- Example: "Send docs by tomorrow"

**✅ Decision Model** (Story 5.2)
- Represents group agreements/conclusions
- Has text, timestamp, no time constraints
- Example: "Going to Italian restaurant"

**Why separate models?** Each serves a different purpose with different data requirements. See `docs/AI-FEATURES-OVERVIEW.md` for full comparison.

---

## Acceptance Criteria

### AC1: Event Models Created
- [ ] `Event.swift` created in `Models/` directory
- [ ] Codable struct with all required fields:
  - id, title, date, time, location
  - creatorUserId, createdAt
  - createdInConversationId, createdAtMessageId
  - invitations: [String: Invitation]
  - attendees: [String: Attendee]
- [ ] Supporting types: `Invitation`, `Attendee`, `RSVPStatus` enum
- [ ] Matches Firestore schema from technical spec
- [ ] `EventEntity.swift` created for SwiftData
- [ ] `@Model` class with same fields
- [ ] Relationships configured properly

### AC2: Reminder Models Created
- [ ] `Reminder.swift` created in `Models/` directory
- [ ] Codable struct with all required fields:
  - id, userId, title, dueDate
  - conversationId, sourceMessageId
  - completed, createdAt, notificationId
- [ ] Matches Firestore schema from technical spec
- [ ] `ReminderEntity.swift` created for SwiftData
- [ ] `@Model` class with same fields

### AC3: Decision Models Created
- [ ] `Decision.swift` created in `Models/` directory
- [ ] Codable struct with all required fields:
  - id, userId, text
  - conversationId, sourceMessageId, timestamp
- [ ] Matches Firestore schema from technical spec
- [ ] `DecisionEntity.swift` created for SwiftData
- [ ] `@Model` class with same fields

### AC4: EventService Created
- [ ] `EventService.swift` created in `Services/` directory
- [ ] Methods implemented:
  - `createEvent(_ event: Event) async throws -> Event`
  - `getEvent(id: String) async throws -> Event?`
  - `listEvents(userId: String) async throws -> [Event]`
  - `listEventsForConversation(conversationId: String) async throws -> [Event]`
  - `updateEvent(_ event: Event) async throws`
  - `deleteEvent(id: String) async throws`
  - `addAttendee(eventId: String, userId: String, status: RSVPStatus) async throws`
- [ ] Firestore integration (read/write to `events` collection)
- [ ] Real-time listener support for event updates
- [ ] Error handling for network failures

### AC5: ReminderService Created
- [ ] `ReminderService.swift` created in `Services/` directory
- [ ] Methods implemented:
  - `createReminder(_ reminder: Reminder) async throws -> Reminder`
  - `getReminder(id: String) async throws -> Reminder?`
  - `listReminders(userId: String, completed: Bool?) async throws -> [Reminder]`
  - `listRemindersForConversation(conversationId: String) async throws -> [Reminder]`
  - `updateReminder(_ reminder: Reminder) async throws`
  - `deleteReminder(id: String) async throws`
  - `markComplete(reminderId: String) async throws`
- [ ] Firestore integration (read/write to `reminders` collection)
- [ ] Real-time listener support for reminder updates

### AC6: DecisionService Created
- [ ] `DecisionService.swift` created in `Services/` directory
- [ ] Methods implemented:
  - `createDecision(_ decision: Decision) async throws -> Decision`
  - `getDecision(id: String) async throws -> Decision?`
  - `listDecisions(userId: String) async throws -> [Decision]`
  - `listDecisionsForConversation(conversationId: String) async throws -> [Decision]`
  - `deleteDecision(id: String) async throws`
- [ ] Firestore integration (read/write to `decisions` collection)
- [ ] Real-time listener support for decision updates

### AC7: SwiftData Integration
- [ ] Update `PersistenceController.swift` to include new entities
- [ ] ModelContainer configured with EventEntity, ReminderEntity, DecisionEntity
- [ ] Test save/fetch for each entity type locally
- [ ] Verify no conflicts with existing entities (User, Conversation, Message)

### AC8: Documentation Updated
- [ ] Update `docs/architecture/data-models.md` with Event, Reminder, Decision schemas
- [ ] Add TypeScript interfaces for each model
- [ ] Document relationships between models
- [ ] Add code examples for common operations

### AC9: Firestore Security Rules
- [ ] Update `firebase/firestore.rules` to include:
  - Events collection rules (users can read/write their own events)
  - Reminders collection rules (users can only access their own reminders)
  - Decisions collection rules (users can only access their own decisions)
- [ ] Test rules in Firebase console

### AC10: Service Testing
- [ ] Manual testing: Create/read/update/delete for each model
- [ ] Verify Firestore synchronization works
- [ ] Verify SwiftData local persistence works
- [ ] Test real-time listener updates
- [ ] Test error handling for offline scenarios

---

## Tasks

### Task 1: Event Models (AC1)
- [x] Create `Event.swift` with full schema
- [x] Create supporting types: `Invitation`, `Attendee`, `RSVPStatus`
- [x] Implement Codable conformance
- [x] Create `EventEntity.swift` for SwiftData
- [x] Add `@Model` macro and relationships
- [x] Test JSON encoding/decoding

### Task 2: Reminder Models (AC2)
- [x] Create `Reminder.swift` with full schema
- [x] Implement Codable conformance
- [x] Create `ReminderEntity.swift` for SwiftData
- [x] Add `@Model` macro
- [x] Test JSON encoding/decoding

### Task 3: Decision Models (AC3)
- [x] Create `Decision.swift` with full schema
- [x] Implement Codable conformance
- [x] Create `DecisionEntity.swift` for SwiftData
- [x] Add `@Model` macro
- [x] Test JSON encoding/decoding

### Task 4: EventService Implementation (AC4)
- [x] Create `EventService.swift` file
- [x] Implement Firebase/Firestore reference setup
- [x] Implement CRUD methods
- [x] Implement real-time listener setup
- [x] Add error handling
- [x] Add attendee management methods
- [x] Test all methods with sample data

### Task 5: ReminderService Implementation (AC5)
- [x] Create `ReminderService.swift` file
- [x] Implement Firebase/Firestore reference setup
- [x] Implement CRUD methods
- [x] Implement real-time listener setup
- [x] Add error handling
- [x] Add completion status toggle
- [x] Test all methods with sample data

### Task 6: DecisionService Implementation (AC6)
- [x] Create `DecisionService.swift` file
- [x] Implement Firebase/Firestore reference setup
- [x] Implement CRUD methods
- [x] Implement real-time listener setup
- [x] Add error handling
- [x] Test all methods with sample data

### Task 7: SwiftData Integration (AC7)
- [x] Update `PersistenceController.swift`
- [x] Add new entities to ModelContainer configuration
- [x] Test local persistence for each entity
- [x] Verify migration works with existing data
- [x] Test fetch/save operations

### Task 8: Documentation (AC8)
- [x] Update `data-models.md` with Event schema
- [x] Update `data-models.md` with Reminder schema
- [x] Update `data-models.md` with Decision schema
- [x] Add TypeScript interfaces
- [x] Document relationships
- [x] Add usage examples

### Task 9: Firestore Security Rules (AC9)
- [x] Write rules for `events` collection
- [x] Write rules for `reminders` collection
- [x] Write rules for `decisions` collection
- [x] Test rules in Firebase console
- [x] Deploy rules

### Task 10: Integration Testing (AC10)
- [x] Test Event: create → read → update → delete
- [x] Test Reminder: create → read → complete → delete
- [x] Test Decision: create → read → delete
- [x] Test Firestore sync for each
- [x] Test SwiftData persistence for each
- [x] Test real-time listeners
- [x] Test offline behavior

---

## Technical Notes

### Event Model Schema

```swift
// Event.swift
import Foundation

struct Event: Identifiable, Codable, Hashable {
    let id: String
    let title: String
    let date: Date
    let time: String?           // "HH:mm" format, optional
    let location: String?
    let creatorUserId: String
    let createdAt: Date
    let createdInConversationId: String
    let createdAtMessageId: String
    
    // Multi-chat tracking
    var invitations: [String: Invitation]  // conversationId -> Invitation
    var attendees: [String: Attendee]      // userId -> Attendee
}

struct Invitation: Codable, Hashable {
    let messageId: String
    let invitedUserIds: [String]
}

struct Attendee: Codable, Hashable {
    var status: RSVPStatus
    var rsvpMessageId: String?
    var rsvpConversationId: String?
    var rsvpAt: Date?
}

enum RSVPStatus: String, Codable, CaseIterable {
    case pending
    case accepted
    case declined
}
```

### EventEntity Schema (SwiftData)

```swift
// EventEntity.swift
import Foundation
import SwiftData

@Model
class EventEntity {
    @Attribute(.unique) var id: String
    var title: String
    var date: Date
    var time: String?
    var location: String?
    var creatorUserId: String
    var createdAt: Date
    var createdInConversationId: String
    var createdAtMessageId: String
    
    // Store as JSON string for SwiftData
    var invitationsJSON: String
    var attendeesJSON: String
    
    init(id: String, title: String, date: Date, time: String? = nil, 
         location: String? = nil, creatorUserId: String, createdAt: Date,
         createdInConversationId: String, createdAtMessageId: String,
         invitationsJSON: String = "{}", attendeesJSON: String = "{}") {
        self.id = id
        self.title = title
        self.date = date
        self.time = time
        self.location = location
        self.creatorUserId = creatorUserId
        self.createdAt = createdAt
        self.createdInConversationId = createdInConversationId
        self.createdAtMessageId = createdAtMessageId
        self.invitationsJSON = invitationsJSON
        self.attendeesJSON = attendeesJSON
    }
}
```

### Reminder Model Schema

```swift
// Reminder.swift
import Foundation

struct Reminder: Identifiable, Codable, Hashable {
    let id: String
    let userId: String
    let title: String
    let dueDate: Date
    let conversationId: String
    let sourceMessageId: String
    var completed: Bool
    let createdAt: Date
    var notificationId: String?
}
```

### Decision Model Schema

```swift
// Decision.swift
import Foundation

struct Decision: Identifiable, Codable, Hashable {
    let id: String
    let userId: String
    let text: String
    let conversationId: String
    let sourceMessageId: String
    let timestamp: Date
}
```

### EventService Template

```swift
// EventService.swift
import Foundation
import FirebaseFirestore

class EventService {
    private let db = Firestore.firestore()
    private let eventsCollection = "events"
    
    func createEvent(_ event: Event) async throws -> Event {
        let docRef = db.collection(eventsCollection).document(event.id)
        try docRef.setData(from: event)
        return event
    }
    
    func getEvent(id: String) async throws -> Event? {
        let docRef = db.collection(eventsCollection).document(id)
        let snapshot = try await docRef.getDocument()
        return try? snapshot.data(as: Event.self)
    }
    
    func listEvents(userId: String) async throws -> [Event] {
        let query = db.collection(eventsCollection)
            .whereField("creatorUserId", isEqualTo: userId)
            .order(by: "date", descending: false)
        
        let snapshot = try await query.getDocuments()
        return snapshot.documents.compactMap { try? $0.data(as: Event.self) }
    }
    
    func listEventsForConversation(conversationId: String) async throws -> [Event] {
        let query = db.collection(eventsCollection)
            .whereField("createdInConversationId", isEqualTo: conversationId)
            .order(by: "date", descending: false)
        
        let snapshot = try await query.getDocuments()
        return snapshot.documents.compactMap { try? $0.data(as: Event.self) }
    }
    
    func updateEvent(_ event: Event) async throws {
        let docRef = db.collection(eventsCollection).document(event.id)
        try docRef.setData(from: event, merge: true)
    }
    
    func deleteEvent(id: String) async throws {
        let docRef = db.collection(eventsCollection).document(id)
        try await docRef.delete()
    }
    
    func addAttendee(eventId: String, userId: String, status: RSVPStatus) async throws {
        let docRef = db.collection(eventsCollection).document(eventId)
        let attendee = Attendee(status: status, rsvpMessageId: nil, 
                               rsvpConversationId: nil, rsvpAt: Date())
        
        try await docRef.updateData([
            "attendees.\(userId)": try Firestore.Encoder().encode(attendee)
        ])
    }
    
    // Real-time listener
    func observeEvent(id: String, onChange: @escaping (Event?) -> Void) -> ListenerRegistration {
        let docRef = db.collection(eventsCollection).document(id)
        return docRef.addSnapshotListener { snapshot, error in
            guard let snapshot = snapshot, error == nil else {
                onChange(nil)
                return
            }
            let event = try? snapshot.data(as: Event.self)
            onChange(event)
        }
    }
}
```

### Firestore Security Rules

```javascript
// firestore.rules additions
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Events collection
    match /events/{eventId} {
      // Users can read events they created or are invited to
      allow read: if request.auth != null && (
        resource.data.creatorUserId == request.auth.uid ||
        request.auth.uid in resource.data.attendees.keys()
      );
      
      // Users can create events
      allow create: if request.auth != null &&
        request.resource.data.creatorUserId == request.auth.uid;
      
      // Users can update events they created
      allow update: if request.auth != null &&
        resource.data.creatorUserId == request.auth.uid;
      
      // Users can delete events they created
      allow delete: if request.auth != null &&
        resource.data.creatorUserId == request.auth.uid;
    }
    
    // Reminders collection
    match /reminders/{reminderId} {
      // Users can only access their own reminders
      allow read, write: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId;
    }
    
    // Decisions collection
    match /decisions/{decisionId} {
      // Users can only access their own decisions
      allow read, write: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId;
    }
  }
}
```

---

## Definition of Done

- [ ] All acceptance criteria met (AC1-10)
- [ ] All tasks completed (Tasks 1-10)
- [ ] Event, Reminder, Decision models created
- [ ] SwiftData entities created for all models
- [ ] EventService, ReminderService, DecisionService implemented
- [ ] All services tested with Firestore
- [ ] SwiftData integration working
- [ ] Documentation updated
- [ ] Firestore security rules deployed
- [ ] Manual testing passed for all CRUD operations
- [ ] Code reviewed and follows standards
- [ ] No crashes or compilation errors

---

## Dependencies

**Upstream:** Story 5.0 (Backend Foundation - Python services exist)

**Downstream:** 
- Story 5.1 (Smart Calendar Extraction - needs Event model)
- Story 5.2 (Decision Detection - needs Decision model)
- Story 5.4 (RSVP Tracking - needs Event model + attendee management)
- Story 5.5 (Reminder Extraction - needs Reminder model)

**CRITICAL:** Story 5.1 is **BLOCKED** until this story is complete.

---

## Risks

- **SwiftData Migration:** Adding new entities might affect existing data
  - Mitigation: Test thoroughly, create backup strategy
- **Firestore Schema Changes:** Models must match backend expectations
  - Mitigation: Follow technical spec exactly, validate with backend team
- **Complex Relationships:** Event attendees and invitations are nested structures
  - Mitigation: Use JSON encoding for SwiftData, native dictionaries for Firestore

---

## Testing Strategy

### Manual Testing (Primary Validation)

1. **Event CRUD**
   - Create event with minimal fields → Verify in Firestore
   - Create event with all fields → Verify in Firestore
   - Read event by ID → Verify data matches
   - Update event title → Verify change persists
   - Delete event → Verify removed from Firestore

2. **Reminder CRUD**
   - Create reminder → Verify in Firestore
   - List reminders for user → Verify filtering works
   - Mark complete → Verify status updates
   - Delete reminder → Verify removed

3. **Decision CRUD**
   - Create decision → Verify in Firestore
   - List decisions by conversation → Verify filtering
   - Delete decision → Verify removed

4. **SwiftData Persistence**
   - Save EventEntity locally → Verify fetch works
   - Save ReminderEntity locally → Verify fetch works
   - Save DecisionEntity locally → Verify fetch works
   - Close/reopen app → Verify data persists

5. **Real-time Listeners**
   - Create event in Firestore console → Verify app receives update
   - Update event in another device → Verify app receives change
   - Delete event → Verify app removes from UI

### Unit Testing (Optional)
Unit tests for model encoding/decoding and service methods may be created but are not required.

**Note:** This story will rely on manual testing for validation. Unit tests are optional and may be skipped to meet timeline constraints.

---

## Notes

- This is pure infrastructure - no user-facing UI yet
- Focus on correctness over optimization
- Models must match technical spec schemas exactly
- Services follow same patterns as existing AuthService and FirestoreService
- SwiftData entities are for local caching, Firestore is source of truth
- Real-time listeners are important for multi-device sync

---

## References

- Technical Spec: `docs/architecture/ai-features-technical-spec.md`
  - Event Schema (Firestore): Lines 468-487
  - Reminder Schema: Lines 489-501
  - Decision Schema: Lines 503-512
- Existing Models: `ios-app/MessageAI/Models/`
- Existing Services: `ios-app/MessageAI/Services/FirestoreService.swift`

---

**Story 5.0.5 provides the critical data foundation that all AI features depend on. Without these models and services, no AI feature can save or retrieve data.**

---

## Dev Agent Record

### Completion Notes

Story 5.0.5 successfully implemented - all AI data models, services, and infrastructure are in place:

**Models Created:**
- ✅ Event.swift - Full event model with attendees and invitations tracking
- ✅ EventEntity.swift - SwiftData persistence layer with JSON encoding for complex types
- ✅ Reminder.swift - Personal reminder model with completion tracking
- ✅ ReminderEntity.swift - SwiftData persistence layer
- ✅ Decision.swift - Group decision model
- ✅ DecisionEntity.swift - SwiftData persistence layer

**Services Implemented:**
- ✅ EventService.swift - Full CRUD + real-time listeners + attendee management (fixed async operations)
- ✅ ReminderService.swift - Full CRUD + real-time listeners + completion toggle (fixed async operations)
- ✅ DecisionService.swift - Full CRUD + real-time listeners (fixed async operations)

**Infrastructure Updated:**
- ✅ PersistenceController.swift - Added all three new entities to Schema
- ✅ firestore.rules - Security rules for events, reminders, decisions collections
- ✅ data-models.md - Documentation with TypeScript interfaces
- ✅ Firebase Indexes - Created composite indexes for all query operations

**Testing & Validation:**
- ✅ All 13 automated tests passing (model encoding, CRUD operations, SwiftData persistence)
- ✅ Firestore security rules validated
- ✅ Temporary test infrastructure created and removed after validation

### File List

**New Files Created:**
- ios-app/MessageAI/Models/Event.swift
- ios-app/MessageAI/Models/EventEntity.swift
- ios-app/MessageAI/Models/Reminder.swift
- ios-app/MessageAI/Models/ReminderEntity.swift
- ios-app/MessageAI/Models/Decision.swift
- ios-app/MessageAI/Models/DecisionEntity.swift
- ios-app/MessageAI/Services/EventService.swift
- ios-app/MessageAI/Services/ReminderService.swift
- ios-app/MessageAI/Services/DecisionService.swift
- ios-app/MessageAI/Views/AIModelsTestView.swift (TEMPORARY - to be deleted)

**Modified Files:**
- ios-app/MessageAI/Persistence/PersistenceController.swift
- firebase/firestore.rules
- docs/architecture/data-models.md

### Change Log

1. **Models Implementation** - Created all 6 model files (Event, Reminder, Decision + their Entity variants) with proper Codable conformance and SwiftData @Model macros
2. **Services Implementation** - Created all 3 service files with full CRUD operations, real-time Firestore listeners, and proper error handling. Fixed async/await operations for Firestore writes.
3. **SwiftData Integration** - Updated PersistenceController to include new entities in Schema for both main and in-memory configurations
4. **Security Rules** - Added comprehensive Firestore security rules for events (creator+attendees access), reminders (user-only), and decisions (user-only)
5. **Documentation** - Updated data-models.md with complete schemas and TypeScript interfaces for all three new models
6. **Testing & Validation** - Created temporary test infrastructure, validated all operations, achieved 13/13 tests passing
7. **Firebase Setup** - Created composite indexes for efficient querying:
   - events: (creatorUserId, date), (createdInConversationId, date)
   - reminders: (userId, dueDate)
   - decisions: (userId, timestamp)
8. **Bug Fixes** - Fixed Firestore.Encoder usage to properly await async setData operations

### Debug Log

**Issue 1: Build Errors**
- Problem: Services didn't conform to ObservableObject protocol with @MainActor
- Solution: Removed ObservableObject conformance (not needed for these services)

**Issue 2: Firestore Permission Errors**
- Problem: CREATE succeeded but READ failed with "Missing or insufficient permissions"
- Root Cause: Firestore rules logic error (using request.resource.data for READ operations)
- Solution: Separated read rules (use resource.data) from write rules (use request.resource.data)

**Issue 3: Documents Not Persisting**
- Problem: All operations logged success but documents never appeared in Firestore
- Root Cause: setData(from:) is synchronous, was not being awaited
- Solution: Use Firestore.Encoder() to encode models, then await async setData() call

**Issue 4: Missing Indexes**
- Problem: Queries failed with "requires an index" error
- Solution: Created composite indexes in Firebase Console for all WHERE + ORDER BY queries

### Temporary Files (REMOVED After Validation)

~~Files to DELETE:~~
- ~~`ios-app/MessageAI/Views/AIModelsTestView.swift`~~ ✅ DELETED

~~Changes to REVERT in:~~
- ~~`ios-app/MessageAI/Views/Settings/SettingsView.swift` (remove Developer Tools section)~~ ✅ REVERTED

### Agent Model Used
- Claude Sonnet 4.5 (via Cursor)

