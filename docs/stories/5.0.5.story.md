# Story 5.0.5: iOS Data Models & Services Foundation

**Epic:** 5 - AI-Powered Messaging Features  
**Story Points:** 3  
**Priority:** Critical  
**Assigned To:** @dev  
**Status:** Not Started

---

## User Story

**As a** developer,  
**I want** Swift data models and service layers for Events, Reminders, and Decisions,  
**so that** I can implement AI features that create and manage these entities.

---

## Description

Create the foundational data models and service layers required for all AI-powered features in Epic 5. This includes Swift models for Events, Reminders, and Decisions, their corresponding SwiftData entities for local persistence, and service layers for CRUD operations and Firestore synchronization.

This story is purely infrastructure - no user-facing features yet, but creates the foundation on which all subsequent AI stories depend.

**Critical Note:** Story 5.1 (Smart Calendar Extraction) cannot proceed without Event models and EventService. This story MUST be completed first.

### 🎯 The Three Models: Events, Reminders, Decisions

This story creates data models for three distinct AI features:

**📅 Event Model** (Story 5.1)
- Represents social gatherings, meetings, appointments
- Has date/time, location, attendees
- Example: "Dinner Friday 7pm"

**⏰ Reminder Model** (Story 5.5)
- Represents personal tasks with deadlines
- Has due date, completion status, notification ID
- Example: "Send docs by tomorrow"

**✅ Decision Model** (Story 5.2)
- Represents group agreements/conclusions
- Has text, timestamp, no time constraints
- Example: "Going to Italian restaurant"

**Why separate models?** Each serves a different purpose with different data requirements. See `docs/AI-FEATURES-OVERVIEW.md` for full comparison.

---

## Acceptance Criteria

### AC1: Event Models Created
- [ ] `Event.swift` created in `Models/` directory
- [ ] Codable struct with all required fields:
  - id, title, date, time, location
  - creatorUserId, createdAt
  - createdInConversationId, createdAtMessageId
  - invitations: [String: Invitation]
  - attendees: [String: Attendee]
- [ ] Supporting types: `Invitation`, `Attendee`, `RSVPStatus` enum
- [ ] Matches Firestore schema from technical spec
- [ ] `EventEntity.swift` created for SwiftData
- [ ] `@Model` class with same fields
- [ ] Relationships configured properly

### AC2: Reminder Models Created
- [ ] `Reminder.swift` created in `Models/` directory
- [ ] Codable struct with all required fields:
  - id, userId, title, dueDate
  - conversationId, sourceMessageId
  - completed, createdAt, notificationId
- [ ] Matches Firestore schema from technical spec
- [ ] `ReminderEntity.swift` created for SwiftData
- [ ] `@Model` class with same fields

### AC3: Decision Models Created
- [ ] `Decision.swift` created in `Models/` directory
- [ ] Codable struct with all required fields:
  - id, userId, text
  - conversationId, sourceMessageId, timestamp
- [ ] Matches Firestore schema from technical spec
- [ ] `DecisionEntity.swift` created for SwiftData
- [ ] `@Model` class with same fields

### AC4: EventService Created
- [ ] `EventService.swift` created in `Services/` directory
- [ ] Methods implemented:
  - `createEvent(_ event: Event) async throws -> Event`
  - `getEvent(id: String) async throws -> Event?`
  - `listEvents(userId: String) async throws -> [Event]`
  - `listEventsForConversation(conversationId: String) async throws -> [Event]`
  - `updateEvent(_ event: Event) async throws`
  - `deleteEvent(id: String) async throws`
  - `addAttendee(eventId: String, userId: String, status: RSVPStatus) async throws`
- [ ] Firestore integration (read/write to `events` collection)
- [ ] Real-time listener support for event updates
- [ ] Error handling for network failures

### AC5: ReminderService Created
- [ ] `ReminderService.swift` created in `Services/` directory
- [ ] Methods implemented:
  - `createReminder(_ reminder: Reminder) async throws -> Reminder`
  - `getReminder(id: String) async throws -> Reminder?`
  - `listReminders(userId: String, completed: Bool?) async throws -> [Reminder]`
  - `listRemindersForConversation(conversationId: String) async throws -> [Reminder]`
  - `updateReminder(_ reminder: Reminder) async throws`
  - `deleteReminder(id: String) async throws`
  - `markComplete(reminderId: String) async throws`
- [ ] Firestore integration (read/write to `reminders` collection)
- [ ] Real-time listener support for reminder updates

### AC6: DecisionService Created
- [ ] `DecisionService.swift` created in `Services/` directory
- [ ] Methods implemented:
  - `createDecision(_ decision: Decision) async throws -> Decision`
  - `getDecision(id: String) async throws -> Decision?`
  - `listDecisions(userId: String) async throws -> [Decision]`
  - `listDecisionsForConversation(conversationId: String) async throws -> [Decision]`
  - `deleteDecision(id: String) async throws`
- [ ] Firestore integration (read/write to `decisions` collection)
- [ ] Real-time listener support for decision updates

### AC7: SwiftData Integration
- [ ] Update `PersistenceController.swift` to include new entities
- [ ] ModelContainer configured with EventEntity, ReminderEntity, DecisionEntity
- [ ] Test save/fetch for each entity type locally
- [ ] Verify no conflicts with existing entities (User, Conversation, Message)

### AC8: Documentation Updated
- [ ] Update `docs/architecture/data-models.md` with Event, Reminder, Decision schemas
- [ ] Add TypeScript interfaces for each model
- [ ] Document relationships between models
- [ ] Add code examples for common operations

### AC9: Firestore Security Rules
- [ ] Update `firebase/firestore.rules` to include:
  - Events collection rules (users can read/write their own events)
  - Reminders collection rules (users can only access their own reminders)
  - Decisions collection rules (users can only access their own decisions)
- [ ] Test rules in Firebase console

### AC10: Service Testing
- [ ] Manual testing: Create/read/update/delete for each model
- [ ] Verify Firestore synchronization works
- [ ] Verify SwiftData local persistence works
- [ ] Test real-time listener updates
- [ ] Test error handling for offline scenarios

---

## Tasks

### Task 1: Event Models (AC1)
- [ ] Create `Event.swift` with full schema
- [ ] Create supporting types: `Invitation`, `Attendee`, `RSVPStatus`
- [ ] Implement Codable conformance
- [ ] Create `EventEntity.swift` for SwiftData
- [ ] Add `@Model` macro and relationships
- [ ] Test JSON encoding/decoding

### Task 2: Reminder Models (AC2)
- [ ] Create `Reminder.swift` with full schema
- [ ] Implement Codable conformance
- [ ] Create `ReminderEntity.swift` for SwiftData
- [ ] Add `@Model` macro
- [ ] Test JSON encoding/decoding

### Task 3: Decision Models (AC3)
- [ ] Create `Decision.swift` with full schema
- [ ] Implement Codable conformance
- [ ] Create `DecisionEntity.swift` for SwiftData
- [ ] Add `@Model` macro
- [ ] Test JSON encoding/decoding

### Task 4: EventService Implementation (AC4)
- [ ] Create `EventService.swift` file
- [ ] Implement Firebase/Firestore reference setup
- [ ] Implement CRUD methods
- [ ] Implement real-time listener setup
- [ ] Add error handling
- [ ] Add attendee management methods
- [ ] Test all methods with sample data

### Task 5: ReminderService Implementation (AC5)
- [ ] Create `ReminderService.swift` file
- [ ] Implement Firebase/Firestore reference setup
- [ ] Implement CRUD methods
- [ ] Implement real-time listener setup
- [ ] Add error handling
- [ ] Add completion status toggle
- [ ] Test all methods with sample data

### Task 6: DecisionService Implementation (AC6)
- [ ] Create `DecisionService.swift` file
- [ ] Implement Firebase/Firestore reference setup
- [ ] Implement CRUD methods
- [ ] Implement real-time listener setup
- [ ] Add error handling
- [ ] Test all methods with sample data

### Task 7: SwiftData Integration (AC7)
- [ ] Update `PersistenceController.swift`
- [ ] Add new entities to ModelContainer configuration
- [ ] Test local persistence for each entity
- [ ] Verify migration works with existing data
- [ ] Test fetch/save operations

### Task 8: Documentation (AC8)
- [ ] Update `data-models.md` with Event schema
- [ ] Update `data-models.md` with Reminder schema
- [ ] Update `data-models.md` with Decision schema
- [ ] Add TypeScript interfaces
- [ ] Document relationships
- [ ] Add usage examples

### Task 9: Firestore Security Rules (AC9)
- [ ] Write rules for `events` collection
- [ ] Write rules for `reminders` collection
- [ ] Write rules for `decisions` collection
- [ ] Test rules in Firebase console
- [ ] Deploy rules

### Task 10: Integration Testing (AC10)
- [ ] Test Event: create → read → update → delete
- [ ] Test Reminder: create → read → complete → delete
- [ ] Test Decision: create → read → delete
- [ ] Test Firestore sync for each
- [ ] Test SwiftData persistence for each
- [ ] Test real-time listeners
- [ ] Test offline behavior

---

## Technical Notes

### Event Model Schema

```swift
// Event.swift
import Foundation

struct Event: Identifiable, Codable, Hashable {
    let id: String
    let title: String
    let date: Date
    let time: String?           // "HH:mm" format, optional
    let location: String?
    let creatorUserId: String
    let createdAt: Date
    let createdInConversationId: String
    let createdAtMessageId: String
    
    // Multi-chat tracking
    var invitations: [String: Invitation]  // conversationId -> Invitation
    var attendees: [String: Attendee]      // userId -> Attendee
}

struct Invitation: Codable, Hashable {
    let messageId: String
    let invitedUserIds: [String]
}

struct Attendee: Codable, Hashable {
    var status: RSVPStatus
    var rsvpMessageId: String?
    var rsvpConversationId: String?
    var rsvpAt: Date?
}

enum RSVPStatus: String, Codable, CaseIterable {
    case pending
    case accepted
    case declined
}
```

### EventEntity Schema (SwiftData)

```swift
// EventEntity.swift
import Foundation
import SwiftData

@Model
class EventEntity {
    @Attribute(.unique) var id: String
    var title: String
    var date: Date
    var time: String?
    var location: String?
    var creatorUserId: String
    var createdAt: Date
    var createdInConversationId: String
    var createdAtMessageId: String
    
    // Store as JSON string for SwiftData
    var invitationsJSON: String
    var attendeesJSON: String
    
    init(id: String, title: String, date: Date, time: String? = nil, 
         location: String? = nil, creatorUserId: String, createdAt: Date,
         createdInConversationId: String, createdAtMessageId: String,
         invitationsJSON: String = "{}", attendeesJSON: String = "{}") {
        self.id = id
        self.title = title
        self.date = date
        self.time = time
        self.location = location
        self.creatorUserId = creatorUserId
        self.createdAt = createdAt
        self.createdInConversationId = createdInConversationId
        self.createdAtMessageId = createdAtMessageId
        self.invitationsJSON = invitationsJSON
        self.attendeesJSON = attendeesJSON
    }
}
```

### Reminder Model Schema

```swift
// Reminder.swift
import Foundation

struct Reminder: Identifiable, Codable, Hashable {
    let id: String
    let userId: String
    let title: String
    let dueDate: Date
    let conversationId: String
    let sourceMessageId: String
    var completed: Bool
    let createdAt: Date
    var notificationId: String?
}
```

### Decision Model Schema

```swift
// Decision.swift
import Foundation

struct Decision: Identifiable, Codable, Hashable {
    let id: String
    let userId: String
    let text: String
    let conversationId: String
    let sourceMessageId: String
    let timestamp: Date
}
```

### EventService Template

```swift
// EventService.swift
import Foundation
import FirebaseFirestore

class EventService {
    private let db = Firestore.firestore()
    private let eventsCollection = "events"
    
    func createEvent(_ event: Event) async throws -> Event {
        let docRef = db.collection(eventsCollection).document(event.id)
        try docRef.setData(from: event)
        return event
    }
    
    func getEvent(id: String) async throws -> Event? {
        let docRef = db.collection(eventsCollection).document(id)
        let snapshot = try await docRef.getDocument()
        return try? snapshot.data(as: Event.self)
    }
    
    func listEvents(userId: String) async throws -> [Event] {
        let query = db.collection(eventsCollection)
            .whereField("creatorUserId", isEqualTo: userId)
            .order(by: "date", descending: false)
        
        let snapshot = try await query.getDocuments()
        return snapshot.documents.compactMap { try? $0.data(as: Event.self) }
    }
    
    func listEventsForConversation(conversationId: String) async throws -> [Event] {
        let query = db.collection(eventsCollection)
            .whereField("createdInConversationId", isEqualTo: conversationId)
            .order(by: "date", descending: false)
        
        let snapshot = try await query.getDocuments()
        return snapshot.documents.compactMap { try? $0.data(as: Event.self) }
    }
    
    func updateEvent(_ event: Event) async throws {
        let docRef = db.collection(eventsCollection).document(event.id)
        try docRef.setData(from: event, merge: true)
    }
    
    func deleteEvent(id: String) async throws {
        let docRef = db.collection(eventsCollection).document(id)
        try await docRef.delete()
    }
    
    func addAttendee(eventId: String, userId: String, status: RSVPStatus) async throws {
        let docRef = db.collection(eventsCollection).document(eventId)
        let attendee = Attendee(status: status, rsvpMessageId: nil, 
                               rsvpConversationId: nil, rsvpAt: Date())
        
        try await docRef.updateData([
            "attendees.\(userId)": try Firestore.Encoder().encode(attendee)
        ])
    }
    
    // Real-time listener
    func observeEvent(id: String, onChange: @escaping (Event?) -> Void) -> ListenerRegistration {
        let docRef = db.collection(eventsCollection).document(id)
        return docRef.addSnapshotListener { snapshot, error in
            guard let snapshot = snapshot, error == nil else {
                onChange(nil)
                return
            }
            let event = try? snapshot.data(as: Event.self)
            onChange(event)
        }
    }
}
```

### Firestore Security Rules

```javascript
// firestore.rules additions
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Events collection
    match /events/{eventId} {
      // Users can read events they created or are invited to
      allow read: if request.auth != null && (
        resource.data.creatorUserId == request.auth.uid ||
        request.auth.uid in resource.data.attendees.keys()
      );
      
      // Users can create events
      allow create: if request.auth != null &&
        request.resource.data.creatorUserId == request.auth.uid;
      
      // Users can update events they created
      allow update: if request.auth != null &&
        resource.data.creatorUserId == request.auth.uid;
      
      // Users can delete events they created
      allow delete: if request.auth != null &&
        resource.data.creatorUserId == request.auth.uid;
    }
    
    // Reminders collection
    match /reminders/{reminderId} {
      // Users can only access their own reminders
      allow read, write: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId;
    }
    
    // Decisions collection
    match /decisions/{decisionId} {
      // Users can only access their own decisions
      allow read, write: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId;
    }
  }
}
```

---

## Definition of Done

- [ ] All acceptance criteria met (AC1-10)
- [ ] All tasks completed (Tasks 1-10)
- [ ] Event, Reminder, Decision models created
- [ ] SwiftData entities created for all models
- [ ] EventService, ReminderService, DecisionService implemented
- [ ] All services tested with Firestore
- [ ] SwiftData integration working
- [ ] Documentation updated
- [ ] Firestore security rules deployed
- [ ] Manual testing passed for all CRUD operations
- [ ] Code reviewed and follows standards
- [ ] No crashes or compilation errors

---

## Dependencies

**Upstream:** Story 5.0 (Backend Foundation - Python services exist)

**Downstream:** 
- Story 5.1 (Smart Calendar Extraction - needs Event model)
- Story 5.2 (Decision Detection - needs Decision model)
- Story 5.4 (RSVP Tracking - needs Event model + attendee management)
- Story 5.5 (Reminder Extraction - needs Reminder model)

**CRITICAL:** Story 5.1 is **BLOCKED** until this story is complete.

---

## Risks

- **SwiftData Migration:** Adding new entities might affect existing data
  - Mitigation: Test thoroughly, create backup strategy
- **Firestore Schema Changes:** Models must match backend expectations
  - Mitigation: Follow technical spec exactly, validate with backend team
- **Complex Relationships:** Event attendees and invitations are nested structures
  - Mitigation: Use JSON encoding for SwiftData, native dictionaries for Firestore

---

## Testing Strategy

### Manual Testing (Primary Validation)

1. **Event CRUD**
   - Create event with minimal fields → Verify in Firestore
   - Create event with all fields → Verify in Firestore
   - Read event by ID → Verify data matches
   - Update event title → Verify change persists
   - Delete event → Verify removed from Firestore

2. **Reminder CRUD**
   - Create reminder → Verify in Firestore
   - List reminders for user → Verify filtering works
   - Mark complete → Verify status updates
   - Delete reminder → Verify removed

3. **Decision CRUD**
   - Create decision → Verify in Firestore
   - List decisions by conversation → Verify filtering
   - Delete decision → Verify removed

4. **SwiftData Persistence**
   - Save EventEntity locally → Verify fetch works
   - Save ReminderEntity locally → Verify fetch works
   - Save DecisionEntity locally → Verify fetch works
   - Close/reopen app → Verify data persists

5. **Real-time Listeners**
   - Create event in Firestore console → Verify app receives update
   - Update event in another device → Verify app receives change
   - Delete event → Verify app removes from UI

### Unit Testing (Optional)
Unit tests for model encoding/decoding and service methods may be created but are not required.

**Note:** This story will rely on manual testing for validation. Unit tests are optional and may be skipped to meet timeline constraints.

---

## Notes

- This is pure infrastructure - no user-facing UI yet
- Focus on correctness over optimization
- Models must match technical spec schemas exactly
- Services follow same patterns as existing AuthService and FirestoreService
- SwiftData entities are for local caching, Firestore is source of truth
- Real-time listeners are important for multi-device sync

---

## References

- Technical Spec: `docs/architecture/ai-features-technical-spec.md`
  - Event Schema (Firestore): Lines 468-487
  - Reminder Schema: Lines 489-501
  - Decision Schema: Lines 503-512
- Existing Models: `ios-app/MessageAI/Models/`
- Existing Services: `ios-app/MessageAI/Services/FirestoreService.swift`

---

**Story 5.0.5 provides the critical data foundation that all AI features depend on. Without these models and services, no AI feature can save or retrieve data.**

