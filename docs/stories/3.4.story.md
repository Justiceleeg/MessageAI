# Story 3.4: Implement Push Notifications

## Status

Draft

## Story

**As a** user,
**I want to** receive push notifications for new messages when I'm not viewing a conversation,
**so that** I don't miss important communications.

## Acceptance Criteria

1. When a new message is received for a conversation the user is not currently viewing, a push notification is delivered to the device (FR8).
2. Notifications work reliably when the app is in the foreground (MVP scope).
3. Tapping a notification navigates the user to the relevant conversation.
4. A Firebase Cloud Function is implemented and deployed to trigger FCM notifications based on new messages in Firestore.
5. FCM device tokens are properly registered, refreshed, and synced to Firestore.

## Tasks / Subtasks

- [ ] Task 1: Update User Data Model for FCM Token (AC: 5)
  - [ ] Add fcmToken field to User model (String?, for push notifications)
  - [ ] Update UserEntity (SwiftData) with fcmToken field if not present
  - [ ] Update User initializer to include fcmToken parameter (default nil)
  - [ ] Update User Codable implementation to include fcmToken
  - [ ] Document User model updates in architecture
  - [ ] Add unit tests for User model with fcmToken field

- [ ] Task 2: Add Firebase Cloud Messaging SDK (AC: 1, 5)
  - [ ] Add FirebaseMessaging package dependency to Xcode project
  - [ ] Update Package.swift or Swift Package Manager dependencies
  - [ ] Import FirebaseMessaging in necessary files
  - [ ] Verify Firebase iOS SDK version compatibility
  - [ ] Test that FirebaseMessaging imports successfully

- [ ] Task 3: Configure APNs in Firebase Console (AC: 1, 2)
  - [ ] Create APNs authentication key in Apple Developer Portal
  - [ ] Download .p8 key file (save securely)
  - [ ] Upload APNs key to Firebase Console: Settings → Cloud Messaging
  - [ ] Enter Key ID and Team ID in Firebase Console
  - [ ] Enable Background Modes capability in Xcode: Remote notifications
  - [ ] Verify APNs configuration in Firebase Console
  - [ ] Document APNs setup process for team reference

- [ ] Task 4: Request Notification Permissions (AC: 1, 2)
  - [ ] Request notification permissions on app launch (after user is authenticated)
  - [ ] Use UNUserNotificationCenter.requestAuthorization(options: [.alert, .sound, .badge])
  - [ ] Register for remote notifications: UIApplication.registerForRemoteNotifications()
  - [ ] Implement AppDelegate didRegisterForRemoteNotificationsWithDeviceToken
  - [ ] Handle permission denial gracefully (don't block app usage)
  - [ ] Store permission status locally (UserDefaults)
  - [ ] Don't repeatedly prompt if user has denied permissions
  - [ ] Add unit tests for permission request logic

- [ ] Task 5: Register and Sync FCM Token (AC: 5)
  - [ ] Fetch FCM token using Messaging.messaging().token(completion:)
  - [ ] Save FCM token to Firestore user document on successful retrieval
  - [ ] Update user document: Set fcmToken field
  - [ ] Only update Firestore if token changed (compare with cached token, learning from 3.2)
  - [ ] Cache token locally in UserDefaults to avoid redundant writes
  - [ ] Handle token refresh: Listen to Messaging.messaging().tokenRefresh notification
  - [ ] Update Firestore when token refreshes
  - [ ] Add error handling for token fetch failures
  - [ ] Add debug logging for all token operations
  - [ ] Add unit tests for FCM token management logic

- [ ] Task 6: Implement Foreground Notification Handling (AC: 2, 3)
  - [ ] Implement UNUserNotificationCenterDelegate in AppDelegate or App struct
  - [ ] Set delegate: UNUserNotificationCenter.current().delegate = self
  - [ ] Implement userNotificationCenter(_:willPresent:withCompletionHandler:)
  - [ ] For foreground: Show banner notification ([.banner, .sound])
  - [ ] Parse notification payload: Extract conversationId from userInfo
  - [ ] Check if user is currently viewing the conversation (suppress notification if yes)
  - [ ] Track currently viewed conversationId in app state
  - [ ] Show notification banner if user is NOT viewing that conversation
  - [ ] Add debug logging for notification display decisions
  - [ ] Add unit tests for notification suppression logic

- [ ] Task 7: Implement Notification Tap Handling (AC: 3)
  - [ ] Implement userNotificationCenter(_:didReceive:withCompletionHandler:)
  - [ ] Extract conversationId from notification userInfo data
  - [ ] Navigate to ChatView for the conversationId
  - [ ] Use NavigationPath or state management for deep linking
  - [ ] Handle case where app is in background vs. foreground
  - [ ] Update UI to scroll to latest message after navigation
  - [ ] Handle case where conversation no longer exists (graceful error)
  - [ ] Add debug logging for navigation events
  - [ ] Test notification tap navigation with simulator and device

- [ ] Task 8: Create Firebase Cloud Function for Notifications (AC: 4)
  - [ ] Initialize firebase-functions directory: firebase init functions
  - [ ] Choose TypeScript as language
  - [ ] Install dependencies: firebase-functions, firebase-admin
  - [ ] Create src/notifications.ts module
  - [ ] Implement sendNewMessageNotification Cloud Function
  - [ ] Trigger: Firestore onCreate on conversations/{conversationId}/messages/{messageId}
  - [ ] Extract messageData, conversationId, senderId from trigger event
  - [ ] Add comprehensive error handling and logging
  - [ ] Add TypeScript type definitions for all data structures
  - [ ] Add unit tests using firebase-functions-test

- [ ] Task 9: Fetch Conversation and Participants in Cloud Function (AC: 4)
  - [ ] Fetch conversation document from Firestore
  - [ ] Extract participants array from conversation
  - [ ] Filter out sender from recipients list
  - [ ] Handle case where conversation not found (log warning, return)
  - [ ] Handle empty recipients list (log info, return)
  - [ ] Extract conversation metadata: isGroupChat, groupName
  - [ ] Add error handling for Firestore query failures
  - [ ] Add logging with context (conversationId, participantCount)

- [ ] Task 10: Fetch FCM Tokens and User Display Names (AC: 4)
  - [ ] Fetch sender's user document to get displayName
  - [ ] Use displayName in notification title (fallback to "Someone")
  - [ ] Loop through recipients and fetch their user documents
  - [ ] Extract fcmToken from each recipient's user document
  - [ ] Build array of FCM tokens for all recipients
  - [ ] Skip recipients without fcmToken (they haven't granted permissions)
  - [ ] Handle missing user documents gracefully
  - [ ] Add logging for token fetch results (count found vs. total recipients)

- [ ] Task 11: Construct Notification Payload (AC: 1, 2, 4)
  - [ ] Define notification title based on chat type
  - [ ] For 1:1 chats: Title = "[SenderName]"
  - [ ] For group chats: Title = "[SenderName] in [GroupName]" or "[SenderName] in group"
  - [ ] Notification body: Message text preview (truncate to 100 characters)
  - [ ] Data payload: Include conversationId, senderId, messageId
  - [ ] Sound: "default" (system sound)
  - [ ] Badge: Optional (defer for MVP, can add later)
  - [ ] Document payload structure in code comments

- [ ] Task 12: Send FCM Notifications (AC: 1, 4)
  - [ ] Use admin.messaging().sendToDevice(tokens, payload) to send notifications
  - [ ] Handle response: Log success and failure counts
  - [ ] Add retry logic for transient failures (optional, FCM SDK handles some retries)
  - [ ] Handle invalid tokens: Log and optionally remove from Firestore (defer for MVP)
  - [ ] Add comprehensive error logging with context
  - [ ] Return null (Cloud Function success)

- [ ] Task 13: Test and Deploy Firebase Cloud Function (AC: 4)
  - [ ] Test Cloud Function locally using Firebase Emulator Suite
  - [ ] Run: firebase emulators:start --only functions,firestore
  - [ ] Trigger function by writing test message to Firestore emulator
  - [ ] Verify function executes and logs output correctly
  - [ ] Test with mock FCM tokens (emulator mode)
  - [ ] Deploy to Firebase: firebase deploy --only functions
  - [ ] Verify deployment in Firebase Console (Functions tab)
  - [ ] Monitor function logs: firebase functions:log
  - [ ] Test with real iOS device: Send message, verify notification received
  - [ ] Document deployment process and troubleshooting steps

- [ ] Task 14: Update Firestore Security Rules for FCM Tokens (AC: 5)
  - [ ] Allow only the user themselves to update their own fcmToken
  - [ ] Rule: allow update: if request.auth.uid == userId
  - [ ] Restrict fcmToken field updates to authenticated user only
  - [ ] Ensure fcmToken is not exposed in public queries
  - [ ] Test security rules in Firebase Console Rules Playground
  - [ ] Add automated security rules tests using Firebase Emulator
  - [ ] Document security rules changes in architecture docs

- [ ] Task 15: Handle Notification Permission Denial (AC: 1)
  - [ ] Handle case where user denies notification permissions
  - [ ] Show in-app message: "Enable notifications in Settings to receive alerts"
  - [ ] Provide button to open iOS Settings app (UIApplication.openSettingsURLString)
  - [ ] Don't repeatedly prompt if user has denied (check cached status)
  - [ ] Log permission denial for analytics (optional)
  - [ ] Test denial flow and settings navigation
  - [ ] Add UI tests for permission handling

- [ ] Task 16: Handle Edge Cases and Error Scenarios (AC: 1, 2, 4, 5)
  - [ ] Handle FCM token expiration and refresh (listen to token refresh events)
  - [ ] Handle notification while user is viewing that conversation (suppress)
  - [ ] Handle Cloud Function failures gracefully (retry, logging)
  - [ ] Handle missing FCM tokens (user hasn't granted permissions or token not yet fetched)
  - [ ] Handle app termination: Notifications delivered via APNs
  - [ ] Handle network errors during FCM token sync
  - [ ] Handle invalid conversationId in notification tap
  - [ ] Add comprehensive error logging for all failure paths
  - [ ] Add unit tests for error scenarios

- [ ] Task 17: Integration Testing for Push Notifications (AC: 1, 2, 3, 4, 5)
  - [ ] Create NotificationsIntegrationTests.swift (NEW)
  - [ ] Test: User A sends message, User B receives notification (foreground)
  - [ ] Test: User B is viewing chat, no notification shown (suppression)
  - [ ] Test: Notification tap navigates to correct conversation
  - [ ] Test: FCM token registered and saved to Firestore on app launch
  - [ ] Test: FCM token refresh updates Firestore
  - [ ] Test: Cloud Function triggers on new message creation
  - [ ] Test: Cloud Function sends notification with correct payload
  - [ ] Test with Firebase Local Emulator Suite
  - [ ] Mark as MANUAL TESTING REQUIRED for real device FCM testing (learning from 3.1/3.2)
  - [ ] Document manual test scenarios and expected results

- [ ] Task 18: Update Existing Tests for Notifications (AC: 1, 5)
  - [ ] Update UserModelTests to include fcmToken field
  - [ ] Add tests for FCM token sync logic
  - [ ] Add tests for notification permission handling
  - [ ] Verify all existing tests pass with notification features added

## Dev Notes

### Previous Story Insights

**From Story 3.3: Implement User Presence Indicators (Draft)**
- ✅ **Debouncing & Throttling**: 5-second debounce and 90-second intervals minimize Firestore writes
- ✅ **Listener Cleanup**: Proper cleanup prevents memory leaks
- ✅ **Realistic Testing**: Unit tests for logic, integration tests mostly manual

**From Story 3.2: Display Message Read Receipts (Done)**
- ✅ **Batching & Throttling**: Critical for reducing Firestore write costs
- ✅ **Security Rules**: Field-level permissions prevent unintended modifications
- ✅ **Debug Logging**: Comprehensive logging essential for debugging timing/sync issues

**From Story 3.1: Implement Basic Group Chat (Done)**
- ✅ **Group Support**: Group name and participant fetching patterns established
- ✅ **Many Tests Deferred**: Focus on unit tests, defer complex integration tests

**From Story 2.3: Ensure Offline Persistence & Optimistic UI (Done)**
- ✅ **NetworkMonitor**: Available for detecting connectivity before FCM operations
- ✅ **Offline Queue**: Pattern available if we need to queue FCM token updates

**Key Technical Foundation Available:**
✓ Firebase Firestore for data storage  
✓ Firebase Auth for user identification  
✓ MVVM architecture with Services layer  
✓ Real-time Firestore listeners for messages  
✓ Network monitoring (NetworkMonitor)  
✓ Group chat support with participant fetching  

**What This Story Adds:**
- **Push Notifications**: FCM integration for iOS foreground notifications
- **Firebase Cloud Function**: Backend trigger for sending notifications on new messages
- **FCM Token Management**: Register, refresh, and sync device tokens to Firestore
- **Notification Handling**: Foreground display, suppression, and tap navigation
- **Backend Development**: First Cloud Function (TypeScript/Node.js)

**Key Learnings Applied from 3.1, 3.2, & 3.3:**
1. **Optimize Writes**: Only update fcmToken if changed (compare with cached value)
2. **Realistic Testing**: Unit tests for logic, manual testing for end-to-end FCM flow
3. **Debug Logging**: Comprehensive logging for token operations and notification delivery
4. **Security First**: Rules defined early, tested in Firebase Console
5. **Error Handling**: Graceful degradation when permissions denied or tokens unavailable

### Data Models

**User Model Updates** [Source: architecture/data-models.md#User]

The User model needs an fcmToken field for push notifications:

**Updated Model:**
```typescript
interface User {
  userId: string;
  displayName: string;
  email?: string;
  presence: 'online' | 'offline';
  lastSeen: FirebaseFirestore.Timestamp;
  fcmToken?: string;  // NEW - Firebase Cloud Messaging token for push notifications
}
```

**Swift Model (User.swift):**

```swift
struct User: Identifiable, Codable {
    let id: String  // userId
    let displayName: String
    let email: String?
    var presence: String  // "online" or "offline"
    var lastSeen: Date
    var fcmToken: String?  // NEW - FCM token for push notifications
    
    init(id: String, displayName: String, email: String? = nil, 
         presence: String = "offline", lastSeen: Date = Date(), fcmToken: String? = nil) {
        self.id = id
        self.displayName = displayName
        self.email = email
        self.presence = presence
        self.lastSeen = lastSeen
        self.fcmToken = fcmToken
    }
}
```

**Swift Model (UserEntity.swift for SwiftData):**

```swift
@Model
final class UserEntity {
    @Attribute(.unique) var userId: String
    var displayName: String
    var email: String?
    var presence: String
    var lastSeen: Date
    var fcmToken: String?  // NEW
    
    init(userId: String, displayName: String, email: String? = nil, 
         presence: String = "offline", lastSeen: Date = Date(), fcmToken: String? = nil) {
        self.userId = userId
        self.displayName = displayName
        self.email = email
        self.presence = presence
        self.lastSeen = lastSeen
        self.fcmToken = fcmToken
    }
}
```

**FCM Token:**
- Unique device-specific token for push notifications
- Generated by Firebase Cloud Messaging SDK
- Stored in Firestore user document
- Can expire/refresh, must be kept up-to-date
- Optional field (user may deny notification permissions)

### Database Schema

**Firestore Schema Updates** [Source: architecture/database-schema.md]

**users Collection:**
- Document ID: userId
- Fields:
  - `displayName`: string
  - `email`: string (optional)
  - `presence`: string ("online" | "offline")
  - `lastSeen`: timestamp
  - `fcmToken`: string (optional) - NEW

**FCM Token Operations:**

```swift
// Save/update FCM token
db.collection("users").document(userId).updateData([
    "fcmToken": token
])

// Fetch FCM tokens for recipients (in Cloud Function)
const userDoc = await admin.firestore().collection('users').doc(userId).get();
const fcmToken = userDoc.exists ? userDoc.data()!.fcmToken : null;
```

**Firestore Security Rules:**

```javascript
match /users/{userId} {
  // Anyone can read user data (for presence indicators, display names)
  allow read: if request.auth != null;
  
  // Only the user can update their own data
  allow update: if request.auth.uid == userId;
  
  // Restrict updates to allowed fields (presence, lastSeen, fcmToken)
  allow update: if request.auth.uid == userId 
    && request.resource.data.keys().hasOnly(['presence', 'lastSeen', 'fcmToken', 'displayName', 'email']);
}
```

### File Locations & Project Structure

[Source: architecture/unified-project-structure.md]

**iOS Files to Create/Update:**

```
ios-app/MessageAI/
├── Models/
│   ├── User.swift                    (UPDATE - add fcmToken field)
│   └── UserEntity.swift              (UPDATE - add fcmToken field)
├── Services/
│   └── NotificationService.swift     (NEW - optional, FCM token management)
├── MessageAIApp.swift                (UPDATE - notification permissions, FCM setup)
└── AppDelegate.swift                 (UPDATE or CREATE - notification delegates)

ios-app/MessageAITests/
├── UserModelTests.swift              (UPDATE - test fcmToken field)
└── NotificationsIntegrationTests.swift (NEW - end-to-end notification tests)
```

**Backend Files to Create:**

```
firebase-functions/
├── src/
│   ├── index.ts                      (CREATE - export functions)
│   └── notifications.ts              (NEW - push notification Cloud Function)
├── tests/
│   └── notifications.test.ts         (NEW - Jest tests for function)
├── package.json                      (CREATE - dependencies)
├── tsconfig.json                     (CREATE - TypeScript config)
└── .gitignore                        (CREATE - ignore node_modules, etc.)
```

### API Specifications

[Source: architecture/backend-architecture.md, architecture/frontend-architecture.md]

**iOS FCM Token Management:**

```swift
// In AppDelegate or MessageAIApp.swift
import FirebaseMessaging
import FirebaseAuth
import FirebaseFirestore

func setupNotifications() {
    // Request notification permissions
    UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
        if granted {
            DispatchQueue.main.async {
                UIApplication.shared.registerForRemoteNotifications()
            }
        } else {
            print("Notification permissions denied")
        }
    }
    
    // Set notification delegate
    UNUserNotificationCenter.current().delegate = self
    
    // Fetch FCM token
    Messaging.messaging().token { token, error in
        if let error = error {
            print("Error fetching FCM token: \(error)")
        } else if let token = token {
            print("FCM token: \(token)")
            self.saveFCMToken(token)
        }
    }
    
    // Listen for token refresh
    NotificationCenter.default.addObserver(self, selector: #selector(tokenRefreshNotification), 
                                          name: NSNotification.Name.MessagingRegistrationTokenRefreshed, object: nil)
}

func saveFCMToken(_ token: String) {
    guard let userId = Auth.auth().currentUser?.uid else { return }
    
    // Check if token changed (avoid redundant writes)
    let cachedToken = UserDefaults.standard.string(forKey: "fcmToken")
    guard token != cachedToken else {
        print("FCM token unchanged, skipping Firestore update")
        return
    }
    
    Firestore.firestore().collection("users").document(userId).updateData([
        "fcmToken": token
    ]) { error in
        if let error = error {
            print("Error saving FCM token: \(error)")
        } else {
            // Cache token locally
            UserDefaults.standard.set(token, forKey: "fcmToken")
        }
    }
}

@objc func tokenRefreshNotification() {
    Messaging.messaging().token { token, error in
        if let token = token {
            self.saveFCMToken(token)
        }
    }
}
```

**iOS Notification Handling:**

```swift
extension AppDelegate: UNUserNotificationCenterDelegate {
    // Handle foreground notifications
    func userNotificationCenter(_ center: UNUserNotificationCenter,
                               willPresent notification: UNNotification,
                               withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        let userInfo = notification.request.content.userInfo
        
        guard let conversationId = userInfo["conversationId"] as? String else {
            completionHandler([])
            return
        }
        
        // Check if user is viewing this conversation (suppress notification)
        if isViewingConversation(conversationId) {
            print("User is viewing conversation \(conversationId), suppressing notification")
            completionHandler([])
        } else {
            // Show notification banner with sound
            completionHandler([.banner, .sound])
        }
    }
    
    // Handle notification tap
    func userNotificationCenter(_ center: UNUserNotificationCenter,
                               didReceive response: UNNotificationResponse,
                               withCompletionHandler completionHandler: @escaping () -> Void) {
        let userInfo = response.notification.request.content.userInfo
        
        if let conversationId = userInfo["conversationId"] as? String {
            // Navigate to ChatView
            NotificationCenter.default.post(
                name: .navigateToConversation, 
                object: nil, 
                userInfo: ["conversationId": conversationId]
            )
        }
        
        completionHandler()
    }
    
    private func isViewingConversation(_ conversationId: String) -> Bool {
        // Check app state to see if user is currently viewing this conversation
        // Implementation depends on your state management approach
        return false  // Placeholder
    }
}

extension Notification.Name {
    static let navigateToConversation = Notification.Name("navigateToConversation")
}
```

**Firebase Cloud Function (TypeScript):**

```typescript
// firebase-functions/src/notifications.ts
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';

export const sendNewMessageNotification = functions.firestore
    .document('conversations/{conversationId}/messages/{messageId}')
    .onCreate(async (snapshot, context) => {
        const messageData = snapshot.data();
        const conversationId = context.params.conversationId;
        const senderId = messageData.senderId;
        const messageText = messageData.text;
        
        try {
            // 1. Get conversation participants
            const conversationDoc = await admin.firestore()
                .collection('conversations')
                .doc(conversationId)
                .get();
            
            if (!conversationDoc.exists) {
                functions.logger.warn(`Conversation ${conversationId} not found`);
                return null;
            }
            
            const conversationData = conversationDoc.data()!;
            const participants: string[] = conversationData.participants || [];
            const isGroupChat: boolean = conversationData.isGroupChat || false;
            const groupName: string | undefined = conversationData.groupName;
            
            // Filter out sender
            const recipients = participants.filter(uid => uid !== senderId);
            if (recipients.length === 0) {
                functions.logger.info('No recipients to notify');
                return null;
            }
            
            // 2. Fetch sender's display name
            const senderDoc = await admin.firestore()
                .collection('users')
                .doc(senderId)
                .get();
            const senderName = senderDoc.exists 
                ? senderDoc.data()!.displayName 
                : 'Someone';
            
            // 3. Fetch FCM tokens for recipients
            const tokens: string[] = [];
            for (const recipientId of recipients) {
                const userDoc = await admin.firestore()
                    .collection('users')
                    .doc(recipientId)
                    .get();
                
                if (userDoc.exists && userDoc.data()!.fcmToken) {
                    tokens.push(userDoc.data()!.fcmToken);
                }
            }
            
            if (tokens.length === 0) {
                functions.logger.info('No FCM tokens found for recipients');
                return null;
            }
            
            // 4. Construct notification payload
            let title = senderName;
            if (isGroupChat) {
                title = groupName 
                    ? `${senderName} in ${groupName}` 
                    : `${senderName} in group`;
            }
            
            const payload = {
                notification: {
                    title: title,
                    body: messageText.substring(0, 100), // Truncate to 100 chars
                    sound: 'default'
                },
                data: {
                    conversationId: conversationId,
                    senderId: senderId,
                    messageId: snapshot.id
                }
            };
            
            // 5. Send notifications
            const response = await admin.messaging().sendToDevice(tokens, payload);
            functions.logger.info(`Sent ${response.successCount} notifications to ${tokens.length} devices`);
            
            return null;
            
        } catch (error) {
            functions.logger.error('Error sending notifications:', error);
            return null;
        }
    });
```

**Firebase Function Index:**

```typescript
// firebase-functions/src/index.ts
import * as admin from 'firebase-admin';

// Initialize Firebase Admin SDK
admin.initializeApp();

// Export Cloud Functions
export { sendNewMessageNotification } from './notifications';
```

### Component Specifications

[Source: architecture/components.md]

**No UI components** to create for this story. Notifications are system-level (iOS banner) and navigation is handled by existing views.

**Integration Points:**
- ConversationListView: Already exists, will receive navigation from notification tap
- ChatView: Already exists, target of notification navigation
- MessageAIApp: Add notification setup and lifecycle hooks

### Testing Requirements

[Source: architecture/testing-strategy.md]

**iOS Unit Tests:**

File: `MessageAITests/UserModelTests.swift`
- Test User model with fcmToken field
- Test fcmToken Codable encoding/decoding

File: `MessageAITests/NotificationHandlingTests.swift` (NEW)
- Test FCM token registration logic
- Test FCM token caching (avoid redundant writes)
- Test notification suppression when viewing conversation
- Test notification tap payload extraction

**iOS Integration Tests:**

File: `MessageAITests/NotificationsIntegrationTests.swift` (NEW)
- Test: FCM token syncs to Firestore on app launch
- Test: FCM token refresh updates Firestore
- Test: Notification tap navigates to correct conversation
- Mark as MANUAL TESTING REQUIRED for end-to-end FCM with real devices
- Document manual test scenarios

**Backend Tests (Jest):**

File: `firebase-functions/tests/notifications.test.ts` (NEW)
- Test: Cloud Function triggers on new message creation
- Test: Function fetches conversation participants
- Test: Function filters out sender from recipients
- Test: Function fetches sender display name
- Test: Function fetches FCM tokens for recipients
- Test: Function constructs correct notification payload (1:1 and group)
- Test: Function sends notifications via FCM
- Test: Function handles missing conversation gracefully
- Test: Function handles missing FCM tokens gracefully
- Use firebase-functions-test for emulation

**Test Location:**
- iOS Unit/Integration: `ios-app/MessageAITests/`
- Backend: `firebase-functions/tests/`
- XCTest for iOS, Jest for Cloud Functions

### Technical Constraints

[Source: architecture/tech-stack.md, architecture/coding-standards.md]

**Versions:**
- Swift: 5.9+
- SwiftUI: Latest (iOS 17+)
- Firebase iOS SDK: Latest (includes FirebaseMessaging)
- Node.js: 18.x LTS (for Cloud Functions)
- TypeScript: 5.x
- firebase-functions: Latest
- firebase-admin: Latest

**Firebase Cloud Messaging:**
- Requires APNs authentication key configured in Firebase Console
- FCM tokens can expire and refresh (must handle token refresh events)
- Notifications require user permission grant
- Foreground notifications controlled by UNNotificationPresentationOptions

**Cloud Functions:**
- Firestore onCreate trigger for messages
- Use admin.messaging().sendToDevice() for FCM sends
- Admin SDK has elevated privileges (use carefully)
- Async/await for Firestore operations
- Comprehensive error handling and logging

**Performance:**
- Cache FCM token locally to avoid redundant Firestore writes
- Batch notification sends when possible (sendToDevice supports arrays)
- Cloud Function execution time: Aim for < 2 seconds

**Security:**
- FCM tokens are device-specific, not user-specific
- Firestore Security Rules restrict fcmToken updates to own user
- Never expose FCM tokens in client-side queries
- Cloud Functions have admin privileges (validate all inputs)

**Error Handling:**
- Handle notification permission denials gracefully (don't block app)
- Log Cloud Function errors with context for debugging
- Retry transient failures (FCM SDK handles some automatically)
- Handle missing FCM tokens (user may have denied permissions)

### UI/UX Patterns

**Notification Banner (Foreground):**
- System notification banner at top of screen
- Title: "[SenderName]" or "[SenderName] in [GroupName]"
- Body: Message text preview (first 100 characters)
- Sound: Default system notification sound
- Tapping navigates to conversation

**Permission Prompt:**
- Request permissions after user authenticates (not on first launch)
- System permission alert: "Allow MessageAI to send you notifications?"
- If denied: Show in-app message with "Open Settings" button
- Don't repeatedly prompt after denial

**Suppression Logic:**
- Don't show notification if user is actively viewing that conversation
- Check current ChatView conversationId before displaying notification

**Accessibility:**
- Notification content readable by VoiceOver
- Tapping notification navigates with screen reader support

### Firebase Setup Requirements

**APNs Configuration (Required):**
1. Create APNs authentication key in Apple Developer Portal
2. Download .p8 key file (save securely, can't be re-downloaded)
3. Upload to Firebase Console: Settings → Cloud Messaging → iOS app configuration
4. Enter Key ID and Team ID from Apple Developer Portal
5. Verify configuration shows "APNs Certificates" as active

**Firebase Cloud Messaging Setup:**
1. GoogleService-Info.plist already in project (from previous stories)
2. Add FirebaseMessaging SDK via Swift Package Manager
3. Enable Background Modes capability in Xcode: Remote notifications
4. Register device token with Firebase (handled in code)

**Cloud Functions Deployment:**
1. Install Firebase CLI: `npm install -g firebase-tools`
2. Initialize Functions: `firebase init functions` (select TypeScript)
3. Install dependencies: `cd firebase-functions && npm install`
4. Deploy: `firebase deploy --only functions`
5. Monitor logs: `firebase functions:log`
6. View deployed functions in Firebase Console → Functions tab

### Project Structure Notes

[Source: architecture/unified-project-structure.md]

**This story requires backend development:**

```
MessageAI/
├── ios-app/                  (existing)
├── firebase-functions/       (NEW - create this directory)
│   ├── src/
│   │   ├── index.ts
│   │   └── notifications.ts
│   ├── tests/
│   │   └── notifications.test.ts
│   ├── package.json
│   ├── tsconfig.json
│   ├── .gitignore
│   └── .eslintrc.js
└── docs/                     (existing)
```

**Backend Development:**
- Language: TypeScript
- Runtime: Node.js 18.x
- Framework: firebase-functions
- Testing: Jest + firebase-functions-test
- Linting: ESLint (auto-configured by firebase init)

**Deployment:**
- Use Firebase CLI: `firebase deploy --only functions`
- Functions deployed to Firebase Cloud (serverless)
- Automatically scales with usage

### External APIs

[Source: architecture/external-apis.md]

**Firebase Services:**
- **Firebase Cloud Messaging (FCM)**: Push notification delivery
- **Firebase Cloud Functions**: Backend trigger for notifications
- **Firebase Firestore**: Data storage for tokens and messages
- **Apple Push Notification service (APNs)**: iOS notification delivery

**No third-party APIs** outside of Firebase ecosystem.

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation (split from 3.3) for Epic 3 | Bob (SM) |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be recorded by Dev Agent_

### Debug Log References

_To be recorded by Dev Agent_

### Completion Notes List

_To be recorded by Dev Agent_

### File List

_To be recorded by Dev Agent_

---

## QA Results

_To be populated by QA Agent_

