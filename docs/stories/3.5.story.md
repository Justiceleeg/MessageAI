# Story 3.5: Typing Indicators

**Epic:** 3 - Group Chat & Presence Features  
**Story Points:** 3  
**Priority:** Medium  
**Assigned To:** @dev  
**Status:** Approved

---

## User Story

**As a** user in an active conversation,  
**I want** to see when the other person is typing,  
**so that** I know they're composing a response and can anticipate their reply.

---

## Description

Display real-time "typing..." indicators when users are composing messages. This enhances the conversational feel by providing immediate feedback about the other person's engagement. Uses Firebase Firestore presence system to broadcast typing state with automatic cleanup.

Typing indicators should appear smoothly, not distract from the conversation, and work reliably in both 1:1 and group chat scenarios.

---

## Acceptance Criteria

### AC1: Typing State Detection
- [ ] Detect when user starts typing (keyboard appears, text field has focus)
- [ ] Detect when user stops typing (2 seconds of inactivity)
- [ ] Detect when user sends message (clear typing state)
- [ ] Detect when user leaves chat view (clear typing state)
- [ ] Debounce rapid typing state changes (300ms)

### AC2: Typing State Broadcast
- [ ] When typing starts, update Firestore presence document
- [ ] Document path: `conversations/{conversationId}/presence/{userId}`
- [ ] Set `isTyping: true` with timestamp
- [ ] Automatic cleanup if user disconnects (Firebase onDisconnect)
- [ ] When typing stops, set `isTyping: false`
- [ ] Throttle updates (max 1 per second to reduce writes)

### AC3: Typing State Display (1:1 Chat)
- [ ] When other user is typing, show indicator on the bottom left of the chat screen
- [ ] Format: "[Name] is typing..."
- [ ] Animated ellipsis (fade in/out or dot animation)
- [ ] Indicator appears smoothly (fade in animation)
- [ ] Indicator disappears when typing stops (fade out)
- [ ] Positioned at bottom of message list, scrolls naturally

### AC4: Typing State Display (Group Chat)
- [ ] Show indicator when any participant is typing
- [ ] Format for 1 person: "[Alice] is typing..."
- [ ] Format for 2 people: "[Alice] and [Bob] are typing..."
- [ ] Format for 3+ people: "[Alice], [Bob], and 2 others are typing..."
- [ ] Update dynamically as people start/stop typing
- [ ] Max 3 names shown explicitly

### AC5: Visual Design
- [ ] Typing indicator styled subtly (gray text, small font)
- [ ] Ellipsis animation smooth (60 FPS)
- [ ] Doesn't push messages up aggressively
- [ ] Works in light and dark mode
- [ ] Consistent with app's design language
- [ ] Accessible (VoiceOver announces typing state)

### AC6: Performance & Edge Cases
- [ ] No typing indicator for own messages
- [ ] Typing state cleared when app backgrounded
- [ ] Typing state cleared on network disconnect
- [ ] No stale indicators (auto-timeout after 10 seconds)
- [ ] Minimal Firestore writes (throttled updates)
- [ ] Works reliably with 10+ participants in group

### AC7: Presence Service Integration
- [ ] Extend existing `PresenceService.swift`
- [ ] Add `startTyping(conversationId:)` method
- [ ] Add `stopTyping(conversationId:)` method
- [ ] Add `observeTypingUsers(conversationId:)` method
- [ ] Handle cleanup on disconnect
- [ ] Integrate with existing online/offline presence

---

## Tasks

### Task 1: Firestore Schema (AC2)
- [ ] Define presence document structure:
  ```
  conversations/{conversationId}/presence/{userId}
    - userId: string
    - isOnline: boolean (existing)
    - lastSeen: Timestamp (existing)
    - isTyping: boolean (NEW)
    - typingAt: Timestamp (NEW)
  ```
- [ ] Update Firestore security rules for presence reads/writes
- [ ] Test presence document creation

### Task 2: PresenceService Extension (AC2, AC7)
- [ ] Extend `PresenceService.swift`
- [ ] Add typing state management methods
- [ ] Implement throttling (max 1 update/second)
- [ ] Add Firebase onDisconnect cleanup for typing state
- [ ] Handle multiple conversations (track typing per conversation)
- [ ] Add Combine publishers for typing state changes

### Task 3: ChatView Typing Detection (AC1)
- [ ] Add text field `.onChange` handler
- [ ] Debounce typing detection (300ms)
- [ ] Call `PresenceService.startTyping()` on first keystroke
- [ ] Set up 2-second timer for inactivity
- [ ] Call `PresenceService.stopTyping()` on timeout
- [ ] Clear typing on message send
- [ ] Clear typing on view disappear

### Task 4: Typing Indicator UI Component (AC3, AC5)
- [ ] Create `TypingIndicatorView` SwiftUI component
- [ ] Animated ellipsis (3 dots fading in/out)
- [ ] Display username(s) dynamically
- [ ] Fade in/out animations
- [ ] Position at bottom of message list
- [ ] Style for light and dark mode
- [ ] Add VoiceOver accessibility

### Task 5: ChatViewModel Integration (AC6)
- [ ] Add `@Published var typingUsers: [User]` state
- [ ] Observe typing presence changes from Firestore
- [ ] Filter out current user
- [ ] Add timeout mechanism (clear after 10 seconds)
- [ ] Handle background/foreground transitions
- [ ] Update typing users list reactively

### Task 6: Group Chat Support (AC4)
- [ ] Extend `TypingIndicatorView` for multiple users
- [ ] Format text based on number of typing users
- [ ] Show max 3 names + count of others
- [ ] Update text dynamically as users start/stop
- [ ] Test with 5+ simultaneous typers

### Task 7: Performance Optimization (AC6)
- [ ] Throttle Firestore writes (1 per second)
- [ ] Debounce typing state changes (300ms)
- [ ] Cleanup listeners on view dismissal
- [ ] Test with slow network
- [ ] Verify no excessive writes in Firebase console

### Task 8: Edge Case Handling (AC6)
- [ ] Handle network disconnection (clear typing state)
- [ ] Handle app backgrounding (stop typing)
- [ ] Handle rapid typing/deletion (debounce)
- [ ] Handle conversation switching (cleanup)
- [ ] Test with multiple open chat views

### Task 9: Manual Testing (AC1-7)
- [ ] Test 1:1 chat typing indicators
- [ ] Test group chat with multiple typers
- [ ] Test rapid typing (no flickering)
- [ ] Test network disconnect
- [ ] Test app backgrounding
- [ ] Test with 10+ participants
- [ ] Verify Firebase writes are throttled (check console)

### Task 10: Accessibility & Polish (AC5)
- [ ] Test with VoiceOver
- [ ] Test in light and dark mode
- [ ] Verify animation smoothness (60 FPS)
- [ ] Test with long usernames
- [ ] Verify no layout jank

---

## Technical Notes

### Firestore Presence Document Structure
```typescript
// conversations/{conversationId}/presence/{userId}
interface UserPresence {
  userId: string
  isOnline: boolean        // Existing field
  lastSeen: Timestamp      // Existing field
  isTyping: boolean        // NEW
  typingAt: Timestamp      // NEW
}
```

### PresenceService Extension
```swift
// Services/PresenceService.swift

class PresenceService: ObservableObject {
    // ... existing code ...
    
    private var typingTimers: [String: Timer] = [:]  // conversationId -> Timer
    private var lastTypingUpdate: [String: Date] = [:]  // conversationId -> Date
    private let typingThrottle: TimeInterval = 1.0  // Max 1 update/second
    
    func startTyping(in conversationId: String) {
        // Throttle updates
        if let lastUpdate = lastTypingUpdate[conversationId],
           Date().timeIntervalSince(lastUpdate) < typingThrottle {
            return
        }
        
        // Update Firestore
        let presenceRef = db.collection("conversations")
            .document(conversationId)
            .collection("presence")
            .document(currentUserId)
        
        presenceRef.updateData([
            "isTyping": true,
            "typingAt": FieldValue.serverTimestamp()
        ])
        
        lastTypingUpdate[conversationId] = Date()
        
        // Set up auto-stop timer (2 seconds)
        typingTimers[conversationId]?.invalidate()
        typingTimers[conversationId] = Timer.scheduledTimer(
            withTimeInterval: 2.0,
            repeats: false
        ) { [weak self] _ in
            self?.stopTyping(in: conversationId)
        }
    }
    
    func stopTyping(in conversationId: String) {
        typingTimers[conversationId]?.invalidate()
        typingTimers[conversationId] = nil
        
        let presenceRef = db.collection("conversations")
            .document(conversationId)
            .collection("presence")
            .document(currentUserId)
        
        presenceRef.updateData([
            "isTyping": false
        ])
    }
    
    func observeTypingUsers(in conversationId: String) -> AnyPublisher<[User], Never> {
        let presenceRef = db.collection("conversations")
            .document(conversationId)
            .collection("presence")
        
        return presenceRef
            .whereField("isTyping", isEqualTo: true)
            .snapshotPublisher()
            .map { snapshot in
                snapshot.documents.compactMap { doc -> User? in
                    let data = doc.data()
                    guard let userId = data["userId"] as? String,
                          userId != self.currentUserId,
                          let isTyping = data["isTyping"] as? Bool,
                          isTyping == true else { return nil }
                    
                    // Check timestamp is recent (< 10 seconds)
                    if let typingAt = data["typingAt"] as? Timestamp {
                        let age = Date().timeIntervalSince(typingAt.dateValue())
                        if age > 10 { return nil }
                    }
                    
                    return self.getUser(userId)  // Fetch user details
                }
            }
            .replaceError(with: [])
            .eraseToAnyPublisher()
    }
}
```

### TypingIndicatorView
```swift
// Views/Shared/TypingIndicatorView.swift
import SwiftUI

struct TypingIndicatorView: View {
    let typingUsers: [User]
    @State private var animationPhase = 0
    
    var body: some View {
        if !typingUsers.isEmpty {
            HStack(spacing: 4) {
                Text(typingText)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                HStack(spacing: 2) {
                    ForEach(0..<3) { index in
                        Circle()
                            .fill(Color.secondary)
                            .frame(width: 4, height: 4)
                            .opacity(animationPhase == index ? 1.0 : 0.3)
                    }
                }
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
            .transition(.opacity.combined(with: .move(edge: .bottom)))
            .onAppear {
                withAnimation(.easeInOut(duration: 0.6).repeatForever()) {
                    animationPhase = (animationPhase + 1) % 3
                }
            }
            .accessibilityLabel("\(typingText) typing")
        }
    }
    
    private var typingText: String {
        switch typingUsers.count {
        case 1:
            return "\(typingUsers[0].displayName) is typing"
        case 2:
            return "\(typingUsers[0].displayName) and \(typingUsers[1].displayName) are typing"
        case 3...Int.max:
            let names = typingUsers.prefix(2).map { $0.displayName }.joined(separator: ", ")
            let others = typingUsers.count - 2
            return "\(names), and \(others) \(others == 1 ? "other" : "others") are typing"
        default:
            return ""
        }
    }
}
```

### ChatView Integration
```swift
// Views/Chat/ChatView.swift

@StateObject private var presenceService = PresenceService()
@State private var typingUsers: [User] = []
@State private var typingDebounceTimer: Timer?

var body: some View {
    VStack {
        // ... existing message list ...
        
        // Typing indicator at bottom
        if !typingUsers.isEmpty {
            TypingIndicatorView(typingUsers: typingUsers)
                .transition(.opacity)
        }
        
        // Message input
        MessageInputView(text: $messageText, onSend: sendMessage)
            .onChange(of: messageText) { oldValue, newValue in
                handleTypingChange(oldValue: oldValue, newValue: newValue)
            }
    }
    .onAppear {
        observeTypingUsers()
    }
    .onDisappear {
        presenceService.stopTyping(in: conversation.id)
    }
}

private func handleTypingChange(oldValue: String, newValue: String) {
    // Cancel existing timer
    typingDebounceTimer?.invalidate()
    
    if newValue.isEmpty {
        // Stopped typing
        presenceService.stopTyping(in: conversation.id)
    } else if oldValue.isEmpty {
        // Started typing
        presenceService.startTyping(in: conversation.id)
    } else {
        // Continue typing - reset inactivity timer
        presenceService.startTyping(in: conversation.id)
    }
}

private func observeTypingUsers() {
    presenceService.observeTypingUsers(in: conversation.id)
        .assign(to: &$typingUsers)
}
```

### Firestore Security Rules Update
```javascript
// firebase/firestore.rules

match /conversations/{conversationId}/presence/{userId} {
  // Allow users to update their own presence
  allow write: if request.auth.uid == userId;
  
  // Allow participants to read all presence in their conversations
  allow read: if request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
}
```

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] Typing indicators appear in 1:1 chat
- [ ] Typing indicators work in group chat
- [ ] No stale indicators (auto-cleanup working)
- [ ] Performance optimized (throttled writes)
- [ ] Works in light and dark mode
- [ ] VoiceOver accessible
- [ ] Manual testing passed
- [ ] No excessive Firebase writes (verified in console)
- [ ] Code reviewed and follows standards

---

## Dependencies

**Upstream:**
- Story 1.2 (User Authentication - need userId)
- Story 2.1 (Real-time Messaging - need conversation context)
- Story 3.1 (Basic Group Chat - for group typing indicators)
- Story 3.3 (Presence Service - extends existing presence system)

**Downstream:** None

---

## Testing Strategy

### Manual Test Cases (Primary Validation)

1. **Basic Typing (1:1 Chat)**
   - Open conversation with another user
   - Other user starts typing
   - Expected: "Alice is typing..." appears
   - Other user stops
   - Expected: Indicator disappears after 2 seconds

2. **Group Chat Typing**
   - Group chat with 5 users
   - 2 users start typing
   - Expected: "Alice and Bob are typing..."
   - 3rd user starts typing
   - Expected: "Alice, Bob, and 1 other are typing..."

3. **Rapid Typing**
   - Type rapidly for 10 seconds
   - Expected: Smooth indicator, no flickering
   - Verify Firebase writes are throttled (check console)

4. **Message Send**
   - Start typing
   - Send message
   - Expected: Typing indicator clears immediately

5. **Network Disconnect**
   - Start typing
   - Turn off WiFi
   - Expected: Typing indicator cleared on other device

6. **App Backgrounding**
   - Start typing
   - Background app
   - Expected: Typing indicator cleared on other device

7. **Stale Indicator Prevention**
   - Simulate: User starts typing, app crashes
   - Expected: Indicator auto-clears after 10 seconds

### Performance Testing
- Monitor Firebase writes during typing (should be < 1/second)
- Check animation frame rate (should be 60 FPS)
- Test with 20+ simultaneous typers in group

### Unit Testing (Optional)
Unit tests for typing state management and throttling logic may be created but are not required.

**Note:** This story will rely on manual testing for end-to-end validation. Unit tests are optional and may be skipped to meet timeline constraints.

---

## Notes

- Keep indicator subtle - shouldn't distract from conversation
- Throttling is critical to avoid excessive Firebase writes
- 2-second inactivity timeout is standard UX pattern
- Consider adding haptic feedback when indicator appears (optional polish)
- Group chat typing with 10+ people should gracefully handle overflow

---

## References

- Existing: `PresenceService.swift` (extend this)
- Firebase Presence: https://firebase.google.com/docs/firestore/solutions/presence
- Similar UX: WhatsApp, iMessage, Slack typing indicators

---

**Story 3.5 adds the conversational polish that makes real-time messaging feel alive and responsive.**

