# Story 1.1: New User Account Creation

## Status

Done

## Story

**As a** new user,
**I want** to create a new account,
**so that** I can access the messaging application.

## Acceptance Criteria

1. A user can access a sign-up screen.
2. A user can create a new account using Firebase Auth (e.g., email/password).
3. Upon successful account creation, a corresponding user profile is created in the users collection in Firestore.
4. Upon success, the user is navigated into the main app (e.g., Conversation List View).
5. If sign-up fails, a clear error message is displayed to the user.

## Tasks / Subtasks

- [x] Task 1: Setup Firebase SDK Integration in iOS Project (AC: 2, 3)
  - [x] Add Firebase iOS SDK dependencies to Xcode project
  - [x] Initialize Firebase in MessageAIApp.swift entry point
  - [x] Configure Firebase with GoogleService-Info.plist
  - [x] Verify Firebase connection

- [x] Task 2: Create AuthService for Firebase Authentication (AC: 2, 5)
  - [x] Create `ios-app/MessageAI/Services/AuthService.swift`
  - [x] Implement AuthService as ObservableObject with @Published currentUser property
  - [x] Implement `signUp(email: String, password: String)` method using Firebase Auth SDK
  - [x] Implement error handling with user-friendly error messages using do-catch pattern
  - [x] Add unit tests in `ios-app/MessageAITests/AuthServiceTests.swift`

- [x] Task 3: Create User Data Model (AC: 3)
  - [x] Create User model in `ios-app/MessageAI/Models/User.swift` matching Firestore schema
  - [x] Define properties: userId (String), displayName (String), email (String?), presence (String), lastSeen (Date)
  - [x] Create SwiftData UserEntity model in `ios-app/MessageAI/Models/UserEntity.swift` for local caching
  - [x] Implement model mapping between Firebase User and SwiftData UserEntity

- [x] Task 4: Create FirestoreService for User Profile Creation (AC: 3)
  - [x] Create `ios-app/MessageAI/Services/FirestoreService.swift`
  - [x] Implement FirestoreService as ObservableObject
  - [x] Implement `createUserProfile(userId: String, displayName: String, email: String?)` method
  - [x] Write user document to Firestore `users` collection with fields: userId, displayName, email, presence ("offline"), lastSeen (current timestamp)
  - [x] Handle Firestore write errors with proper error propagation
  - [x] Add unit tests in `ios-app/MessageAITests/FirestoreServiceTests.swift`

- [x] Task 5: Create Sign-Up View UI (AC: 1, 2, 5)
  - [x] Create `ios-app/MessageAI/Views/Auth/SignUpView.swift`
  - [x] Implement SwiftUI form with email TextField, password SecureField, and Sign Up Button
  - [x] Add validation for email format and password requirements
  - [x] Display error alerts for sign-up failures
  - [x] Use native SwiftUI components for consistent iOS look and feel
  - [x] Add SwiftUI Preview for UI testing

- [x] Task 6: Create AuthViewModel for Sign-Up Flow (AC: 2, 3, 4, 5)
  - [x] Create `ios-app/MessageAI/ViewModels/AuthViewModel.swift`
  - [x] Implement AuthViewModel as ObservableObject
  - [x] Inject AuthService and FirestoreService dependencies
  - [x] Implement `signUp(email: String, password: String, displayName: String)` method that:
    - Calls AuthService.signUp()
    - On success, calls FirestoreService.createUserProfile()
    - Updates @Published error state for UI error display
  - [x] Add @Published properties for loading state and error messages
  - [x] Add unit tests in `ios-app/MessageAITests/AuthViewModelTests.swift`

- [x] Task 7: Setup Navigation and Routing (AC: 4)
  - [x] Update MessageAIApp.swift root view to check auth state
  - [x] Use NavigationStack (iOS 16+) for routing
  - [x] Show SignUpView when user is not authenticated
  - [x] Navigate to main app (Conversation List placeholder view) when authentication succeeds
  - [x] Implement protected route pattern based on AuthService.currentUser state

- [x] Task 8: Setup SwiftData Persistence Layer (AC: 3)
  - [x] Create `ios-app/MessageAI/Persistence/PersistenceController.swift`
  - [x] Configure SwiftData ModelContainer with UserEntity model
  - [x] Inject ModelContainer into app environment in MessageAIApp.swift
  - [x] Ensure SwiftData operations run on background threads for UI responsiveness

- [x] Task 9: Integration Testing (AC: 1, 2, 3, 4, 5)
  - [x] Create integration test in `ios-app/MessageAITests/SignUpFlowTests.swift`
  - [x] Test complete sign-up flow: UI → ViewModel → Services → Firebase
  - [x] Verify Firestore user document creation
  - [x] Verify navigation to main app on success
  - [x] Test error scenarios (invalid email, weak password, network errors)

## Dev Notes

### Previous Story Insights

N/A - This is the first story.

### UI/UX Specification

**IMPORTANT**: Complete UI/UX design specification available at: `docs/front-end-spec.md`

This specification includes:
- Complete Sign-Up screen layout and component specifications
- All UI states (default, focused, valid, invalid, loading, error)
- Validation messages and error copy (use exact text from spec)
- VoiceOver accessibility labels (required for WCAG AA compliance)
- Color palette, typography, spacing system (8pt grid)
- Animation specifications with durations and easing curves
- Performance requirements and testing criteria
- Component library for reusable elements

**Task 5 (Create Sign-Up View UI) Implementation:**
- Reference the "Wireframes & Mockups" section for complete screen layout
- Use "Component Library" section for reusable component specs
- Follow "Branding & Style Guide" for all colors, fonts, and spacing
- Implement all "Accessibility Requirements" including VoiceOver labels
- Apply "Animation & Micro-interactions" specifications
- Meet "Performance Considerations" goals and testing criteria

**Key UI Decisions Made:**
- Single-screen form with Display Name + Email + Password fields
- Password show/hide toggle (eye icon inside field, trailing position)
- Password strength indicator (weak/medium/strong with color-coded bar)
- Real-time validation with debouncing (300ms)
- Native iOS aesthetic (system colors, SF Pro font, SF Symbols)
- Full accessibility support (VoiceOver, Dynamic Type, Reduce Motion, keyboard navigation)

### Architecture Context

**Tech Stack** [Source: architecture/tech-stack.md]
- Frontend: Swift 5.9+, SwiftUI (Latest), Native SwiftUI Components
- State Management: SwiftUI built-in (@State, @StateObject, @ObservedObject, @EnvironmentObject)
- Authentication: Firebase Auth (Cloud)
- Database: Firebase Firestore (Remote), SwiftData (iOS 17+ for local cache)
- Backend: TypeScript 5.x, Node.js 18.x LTS for Firebase Cloud Functions
- Testing: XCTest for unit/UI testing, Jest for backend functions

**Project Structure** [Source: architecture/unified-project-structure.md]
```
MessageAI/                  # Root (current: MessageAI)
├── ios-app/                 # Xcode Project (TO BE CREATED - currently flat structure)
│   ├── MessageAI/           # Source code
│   │   ├── Models/          # SwiftData Models & Firebase model mappings
│   │   ├── Views/           # SwiftUI Views (Auth/, Conversations/, Chat/, Settings/, Shared/)
│   │   ├── ViewModels/      # ObservableObjects (AuthViewModel, etc.)
│   │   ├── Services/        # Firebase interaction (AuthService, FirestoreService)
│   │   └── Persistence/     # SwiftData setup (PersistenceController)
│   ├── MessageAI.xcodeproj
│   └── MessageAITests/      # Unit tests
├── firebase-functions/      # TO BE CREATED - Cloud Functions (Node/TS)
└── docs/                    # Current documentation location
```

**IMPORTANT**: Current project has flat structure with `MessageAI/` directory containing Xcode files. The story implementation should work with the existing structure first, then the project can be reorganized to match the monorepo structure in a future story.

**Data Models** [Source: architecture/data-models.md]

User Model (TypeScript Interface - for reference):
```typescript
interface User {
  userId: string;              // Matches Firebase Auth UID
  displayName: string;         // User's chosen display name
  email?: string;              // User's email (optional for lookup)
  presence: 'online' | 'offline';  // User status
  lastSeen: FirebaseFirestore.Timestamp;  // Last activity timestamp
}
```

SwiftData Local Model [Source: architecture/database-schema.md#SwiftData-Schema]:
```swift
@Model
final class UserEntity {
    @Attribute(.unique) var userId: String
    var displayName: String
    var email: String?
    var presence: String // "online" or "offline"
    var lastSeen: Date
    init(userId: String, displayName: String, email: String? = nil, 
         presence: String = "offline", lastSeen: Date = Date()) { /*...*/ }
}
```

**Firestore Schema** [Source: architecture/database-schema.md#Firestore-Schema]
- Collection: `users`
- Document ID: `userId` (matches Firebase Auth UID)
- Fields: displayName (string), email (string, optional), presence (string: "online"/"offline"), lastSeen (timestamp)
- Indexes: Default single-field indexes
- Security Rules: Users can only access their own data and conversations they participate in

**Authentication Flow** [Source: architecture/authentication-and-authorization.md#Auth-Flow]
1. User enters credentials, taps Sign Up
2. App calls AuthService.signUp()
3. AuthService calls Firebase Auth SDK `Auth.createUser()`
4. Firebase Auth verifies and creates user account
5. On success: AuthService updates app state with currentUser
6. App creates user profile in Firestore via FirestoreService
7. App navigates to main view
8. On failure: AuthService returns error, App displays error message to user

**Component Architecture** [Source: architecture/frontend-architecture.md#Component-Architecture]
- Pattern: MVVM (Model-View-ViewModel)
- Views: SwiftUI views in `Views/` directory, organized by feature
- ViewModels: ObservableObjects with @Published properties
- Services: Firebase SDK wrappers (AuthService, FirestoreService)
- Dependency Injection: Services injected into ViewModels

AuthService Template [Source: architecture/frontend-architecture.md#API-Client-Setup]:
```swift
import FirebaseAuth

class AuthService: ObservableObject {
    @Published var currentUser: User?
    
    func signUp(email: String, password: String) async throws -> User {
        // Implementation using Auth.auth().createUser()
    }
    
    func signIn(email: String, password: String) async throws { /* ... */ }
    func signOut() { /* ... */ }
}
```

FirestoreService Template [Source: architecture/frontend-architecture.md#API-Client-Setup]:
```swift
import FirebaseFirestore
import FirebaseFirestoreSwift

class FirestoreService: ObservableObject {
    private let db = Firestore.firestore()
    
    func createUserProfile(userId: String, displayName: String, email: String?) async throws {
        // Write to db.collection("users").document(userId)
    }
}
```

**State Management** [Source: architecture/frontend-architecture.md#State-Management-Architecture]
- Use SwiftUI built-in property wrappers (@State, @StateObject, @ObservedObject, @EnvironmentObject)
- ViewModels expose state via @Published properties
- Single Source of Truth: Firestore (remote), SwiftData (local offline)
- No external state management libraries needed for MVP

**Routing** [Source: architecture/frontend-architecture.md#Routing-Architecture]
- Use NavigationStack (iOS 16+)
- Root view checks auth state to show Auth views or Main App
- Protected Route Pattern: Conditionally render based on AuthService.currentUser state
- For this story: Show SignUpView when not authenticated, navigate to main app on success

**Error Handling** [Source: architecture/error-handling-strategy.md#Frontend-Error-Handling]
- Use do-catch or Result for service calls
- ViewModels catch errors, log using OSLog
- Update @Published error state for UI display
- Display user-friendly error messages via Alert or inline text
- Example: "Invalid email format", "Password too weak", "Network error, please try again"

**Coding Standards** [Source: architecture/coding-standards.md]
- Files: PascalCase (e.g., `AuthService.swift`, `SignUpView.swift`)
- Classes/Structs: PascalCase (e.g., `AuthViewModel`, `UserEntity`)
- Functions/Methods: camelCase (e.g., `signUp()`, `createUserProfile()`)
- Variables: camelCase (e.g., `displayName`, `currentUser`)
- Use official Firebase SDKs
- Consistent error handling: Swift do-catch/Result patterns
- Use SwiftData on background threads for UI responsiveness
- Rely on Firestore Security Rules, don't bypass client-side

**Firebase SDK Setup**
- Add Firebase iOS SDK via Swift Package Manager in Xcode
- Required packages: FirebaseAuth, FirebaseFirestore, FirebaseFirestoreSwift
- Initialize Firebase in app entry point (MessageAIApp.swift) with `FirebaseApp.configure()`
- Requires GoogleService-Info.plist in project (obtain from Firebase Console)

**Security Considerations** [Source: architecture/security-and-performance.md]
- Never store passwords in local cache
- Use Firebase Auth for secure credential handling
- Implement Firestore Security Rules to restrict user data access
- Email validation on client side for better UX, server-side validation by Firebase Auth

### Testing

**Testing Standards** [Source: architecture/testing-strategy.md]

**Test Organization:**
- Unit tests location: `ios-app/MessageAITests/`
- UI tests location: `ios-app/MessageAIUITests/`
- Backend tests location: `firebase-functions/tests/`

**Frontend Testing:**
- Framework: XCTest (Native iOS testing framework)
- Unit tests for ViewModels: Mock services, test business logic
- Unit tests for Services: Mock Firebase SDK calls where possible, or use Firebase Local Emulator Suite
- UI tests: XCUITest for end-to-end user flows
- Test naming convention: `test{MethodName}_{Scenario}_{ExpectedResult}`
- Example: `testSignUp_WithValidCredentials_CreatesUserAndNavigates()`

**Testing Requirements for This Story:**
1. AuthService unit tests:
   - Test successful sign-up
   - Test sign-up with invalid email
   - Test sign-up with weak password
   - Test network error handling

2. FirestoreService unit tests:
   - Test user profile creation
   - Test Firestore write error handling

3. AuthViewModel unit tests:
   - Test sign-up flow coordination
   - Test error state updates
   - Mock both AuthService and FirestoreService

4. Integration test:
   - Test complete sign-up flow from UI to Firebase
   - Verify Firestore document creation
   - Verify navigation to main app

5. UI test:
   - Test sign-up screen displays correctly
   - Test form validation
   - Test error message display

**Test Examples:**
```swift
// Example unit test structure
import XCTest
@testable import MessageAI

final class AuthServiceTests: XCTestCase {
    var authService: AuthService!
    
    override func setUp() {
        super.setUp()
        authService = AuthService()
    }
    
    func testSignUp_WithValidCredentials_ReturnsUser() async throws {
        // Arrange
        let email = "test@example.com"
        let password = "SecurePass123"
        
        // Act
        let user = try await authService.signUp(email: email, password: password)
        
        // Assert
        XCTAssertNotNil(user)
        XCTAssertEqual(user.email, email)
    }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | SM Agent (Bob) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5

### Debug Log References

_To be populated by Dev Agent_

### Completion Notes List

- All 9 tasks completed successfully with unit and integration tests
- Firebase SDK integrated with Auth and Firestore
- Complete sign-up flow implemented: UI → ViewModel → Services → Firebase
- User model created for both Firestore (remote) and SwiftData (local cache)
- Auth-based navigation routing implemented
- SwiftData persistence layer configured
- All acceptance criteria met:
  - AC1: Sign-up screen accessible ✅
  - AC2: User can create account with Firebase Auth ✅
  - AC3: User profile created in Firestore users collection ✅
  - AC4: Navigation to main app after successful sign-up ✅
  - AC5: Error messages displayed on failure ✅

### File List

**Modified:**
- `MessageAI/MessageAIApp.swift` - Added Firebase initialization, auth-based routing, SwiftData ModelContainer injection
- `MessageAI/Views/Auth/SignUpView.swift` - Connected to AuthViewModel via EnvironmentObject

**Added:**
- `MessageAI/GoogleService-Info.plist` - Firebase configuration file
- `MessageAI/Services/AuthService.swift` - Firebase Authentication service with sign up/sign in/sign out
- `MessageAI/Services/FirestoreService.swift` - Firestore service for user profile CRUD operations
- `MessageAI/Models/User.swift` - User model matching Firestore schema with presence status
- `MessageAI/Models/UserEntity.swift` - SwiftData entity for local user caching
- `MessageAI/Views/Auth/SignUpView.swift` - Sign-up UI with validation, password strength indicator, and accessibility
- `MessageAI/Views/Conversations/ConversationListView.swift` - Placeholder main app view with sign-out
- `MessageAI/ViewModels/AuthViewModel.swift` - Coordinates sign-up flow between AuthService and FirestoreService
- `MessageAI/Persistence/PersistenceController.swift` - SwiftData ModelContainer setup with background thread support
- `MessageAITests/AuthServiceTests.swift` - Unit tests for AuthService
- `MessageAITests/FirestoreServiceTests.swift` - Unit tests for FirestoreService
- `MessageAITests/AuthViewModelTests.swift` - Unit tests for AuthViewModel
- `MessageAITests/SignUpFlowTests.swift` - Integration tests for complete sign-up flow

## QA Results

_To be populated by QA Agent_


